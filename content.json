{"pages":[],"posts":[{"title":"AOP日志拦截注解参数方法及存在的问题","text":"AOP日志拦截注解参数方法及存在的问题 1、定义注解 2、配置注解 3、使用注解，放在要拦截的controller层 1、定义注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface LogDes{ public String model() default &quot;&quot;; public String method() default &quot;&quot;;} 2、配置注解123//切点切入自己配置的那个注解 @Pointcut(&quot;@annotation(com.xxx.xx.LogDes)&quot;) //注意这里的写法@annotation() 切入注解 public void annotationLog(){} //随便取一个名字 这时候要注意，在获取代理对象时，如果用默认的代理对象，会获取不到配置AOP注解的的参数，要使用真实对象来获取，以下是代码。 123456789@After(&quot;annotationLog()&quot;) public void after(JoinPoint joinPoint){ MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod();//这个方法才是目标对象上有注解的方法 Method declaredMethod = joinPoint.getTarget().getClass().getDeclaredMethod(signature.getName(), method.getParameterTypes()); LogDes annotation declaredMethod .getAnnotation(LogDes.class); System.out.println( annotation.model+annotation.method ); } 3、使用注解，放在要拦截的controller层12345@LogDes(model=&quot;xx&quot;,method=&quot;xx&quot;)@RequestMapping(&quot;/xxx&quot;)public void xxx(){ ......} 参考博文【1】AOP注解式拦截【2】解决 getAnnotation为null的坑 扩展博客【1】SpringBoot&gt;15 - 自定义注解实现权限控制【2】Spring Boot AOP 自定义注解实现权限控制【3】02 AOP切入点详解","link":"/2021/06/03/AOP%E6%97%A5%E5%BF%97%E6%8B%A6%E6%88%AA%E6%B3%A8%E8%A7%A3%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"CAS与synchronized","text":"synchronized代表的是一种阻塞式的锁，得不到锁会进入阻塞队列，等待线程进行唤醒，有上下文切换的开销。原子变量是非阻塞式的，有冲突一直循环重试。 12345678public final int incrementAndGet() { for(;;) { int current = get(); int next = current + 1; if(compareAndSet(current, next)) return next; }} 基于CAS可以实现乐观非阻塞式算法，还可以悲观阻塞式算法 1234567891011public class MyLock {private AtomicInteger status = new AtomicInteger(0);public void lock() {while(!status.compareAndSet(0, 1)) {Thread.yield();}}public void unlock() {status.compareAndSet(1, 0);}} cas 如何解决ABA问题使用AtomicStampedReference在修改时候同时设置时间戳，值时间戳相同才做相应修改","link":"/2021/12/28/CAS%E4%B8%8Esynchronized/"},{"title":"Consul基本操作","text":"开发者模式 1consul agent -dev 服务模式 可以保留以前数据 1consul agent -server -ui -bootstrap-expect 1 -data-dir D:\\consul\\data -node=n1 -bind=127.0.0.1","link":"/2021/07/10/Consul%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"Dao层封装的JavaBean的属性值为0","text":"今天做的案例中 在Dao层 写的Sql语句，然后通过BeanRowMapper 进行封装 ，封装之后启动项目，前台获取到的数据count 都为0，然后排查调试找原因，后来发现 在Dao层写的sql语句的数据的命名 没有和JavaBean中的属性名称相对应。 譬如 String sql = “select cout(*) as count from tab_route”; 要记得count 名称 和 JavaBean 的属性一直 也得是count","link":"/2020/06/27/Dao%E5%B1%82%E5%B0%81%E8%A3%85%E7%9A%84JavaBean%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%BA0/"},{"title":"Eclipse 报错：java.io.FileNotFoundException：文件名 目录名或卷标语法不正确","text":"在利用 FileReader 可能会遇到“java.io.FileNotFoundException：文件名目录名或卷标语法不正确”异常。 今天遇到这个异常，而且路径都对，文件名也对，但就是报错。 后来发现：通过对目标文件右键属性 粘贴目标文件的路径名到 FileReader fr = new FileReader(**”F:/桌面/a.txt”**);中 这种会引起报错。 而当我重新 将加粗部分路径名删掉重新 用键盘敲上去 异常报错就解决了。所以当出现这种异常可尝试手敲目标文件路径名。","link":"/2019/12/11/Eclipse%20%E6%8A%A5%E9%94%99%EF%BC%9Ajava.io.FileNotFoundException%EF%BC%9A%E6%96%87%E4%BB%B6%E5%90%8D%20%E7%9B%AE%E5%BD%95%E5%90%8D%E6%88%96%E5%8D%B7%E6%A0%87%E8%AF%AD%E6%B3%95%E4%B8%8D%E6%AD%A3%E7%A1%AE/"},{"title":"Freemarker的基本使用","text":"Freemarker的基本使用 基本指令 1、FTL指令 1.1 assign指令 1.2 include指令 1.3 if指令 1.4 list指令 2、内置函数 2.1 获取集合大小size 2.2 json字符串转对象 2.3 日期格式化 3、空值处理 3.1 判断变量是否存在 “??” 3.2 变量不存在使用默认值 “!” 基本指令1、FTL指令1.1 assign指令用于在模板中定义一个变量，可定义一个简单变量，定义对象，定义数组 123&lt;#--定义一个简单变量--&gt; &lt;#assign msg=&quot;Hello Word!&quot;&gt; ${msg} 123&lt;#--定义对象--&gt; &lt;#assign user={&quot;name&quot;:&quot;李四&quot;,&quot;age&quot;:18,&quot;address&quot;:&quot;北京&quot;} &gt; ${user.name}---${user.age}---${user.address} 123&lt;#--定义数组--&gt; &lt;#assign myList=[&quot;唐人街探案3&quot;,&quot;我和我的祖国&quot;]&gt; ${myList[0]}---${myList[1]} 1.2 include指令此指令用于模板文件的嵌套 1&lt;#include &quot;head.ftl&quot;&gt; 1.3 if指令if指令用于判断 12345&lt;#if work==true&gt; 努力工作 &lt;#else&gt; 上班摸鱼&lt;/#if&gt; 1.4 list指令list指令用于循环，分两种形式1、第一种 123&lt;#list 0..10 as num&gt; ${num}&lt;/#list&gt; 2、第二种 123&lt;#list taskList as task&gt; ${task_index +1}---${task.taskType}---${task.priority}---${task.executeTime} &lt;br&gt;&lt;/#list&gt; 2、内置函数2.1 获取集合大小size1234&lt;#list taskList as task&gt; ${task_index +1}---${task.taskType}---${task.priority}---${task.executeTime} &lt;br&gt;&lt;/#list&gt;总共有${taskList?size}个任务 2.2 json字符串转对象1234&lt;#assign taskStr=&quot;{'taskType':1002,'priority':5}&quot;&gt;&lt;#--${taskStr.taskType}--&gt;&lt;#assign task=taskStr?eval&gt;${task.taskType}--${task.priority} 2.3 日期格式化1234日期：${today?date} &lt;br&gt;时间:${today?time} &lt;br&gt;日期+时间:${today?datetime} &lt;br&gt;自定义格式:${today?string('yyyy年-MM月-dd日')} &lt;br&gt; 3、空值处理3.1 判断变量是否存在 “??”12345&lt;#if aaa??&gt; 变量aaa存在 值为${aaa} &lt;#else&gt; 变量aaa不存在&lt;/#if&gt; 3.2 变量不存在使用默认值 “!”1${aaa ! 'aaa不存在显示的默认值'}","link":"/2021/07/31/Freemarker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"Idea使用总结","text":"待更新","link":"/2021/07/08/Idea%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"Java POI导出所选数据","text":"12345678910111213141516171819202122232425262728293031@RequestMapping(&quot;/download&quot;) public void exprotData(HttpServletResponse response) throws IOException { String path=&quot;d:/export&quot;; User user01 = new User(0,&quot;小明&quot;,18); User user02 = new User(1,&quot;小华&quot;,22); User user03 = new User(2,&quot;小王&quot;,23); List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(user01); userList.add(user02); userList.add(user03); //创建工作薄对象 HSSFWorkbook workbook=new HSSFWorkbook(); //创建工作表对象 HSSFSheet sheet = workbook.createSheet(); workbook.createCellStyle().setAlignment(XSSFCellStyle.ALIGN_RIGHT); HSSFRow rowHead = sheet.createRow(0); //设置第一行，从零开始 rowHead.createCell(0).setCellValue(&quot;id&quot;); rowHead.createCell(1).setCellValue(&quot;姓名&quot;); rowHead.createCell(2).setCellValue(&quot;年龄&quot;); for (int i = 0; i &lt; userList.size(); i++) { HSSFRow row = sheet.createRow(i+1); row.createCell(0).setCellValue(i); row.createCell(1).setCellValue(userList.get(i).getName()); row.createCell(2).setCellValue(userList.get(i).getAge()); } //文档输出 FileOutputStream output = new FileOutputStream(path + new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;).format(new Date()).toString() +&quot;.xls&quot;); workbook.write(output); output.close(); }","link":"/2021/06/21/Java%20POI%E5%AF%BC%E5%87%BA%E6%89%80%E9%80%89%E6%95%B0%E6%8D%AE/"},{"title":"Java实习 一周 1月11日-1月15日","text":"写模块","link":"/2021/01/18/Java%E5%AE%9E%E4%B9%A0%20%E4%B8%80%E5%91%A8%201%E6%9C%8811%E6%97%A5-1%E6%9C%8815%E6%97%A5/"},{"title":"Java实习 三周 1月25日-1月31日","text":"1221","link":"/2021/01/25/Java%E5%AE%9E%E4%B9%A0%20%E4%B8%89%E5%91%A8%201%E6%9C%8825%E6%97%A5-1%E6%9C%8831%E6%97%A5/"},{"title":"Java实习 二周 1月18日-1月22日","text":"写文档","link":"/2021/01/20/Java%E5%AE%9E%E4%B9%A0%20%E4%BA%8C%E5%91%A8%201%E6%9C%8818%E6%97%A5-1%E6%9C%8822%E6%97%A5/"},{"title":"Java实习第三天-12月23日","text":"。。。。","link":"/2021/01/18/Java%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9-12%E6%9C%8823%E6%97%A5/"},{"title":"Java实习第二天-12月22日","text":"今天看项目 swagger postman","link":"/2021/01/18/Java%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9-12%E6%9C%8822%E6%97%A5/"},{"title":"Java实习第四天 1月8日","text":"刚去","link":"/2021/01/18/Java%E5%AE%9E%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%A4%A9%201%E6%9C%888%E6%97%A5/"},{"title":"Java实习隔离 12月24日-1月7日","text":"隔离","link":"/2021/01/18/Java%E5%AE%9E%E4%B9%A0%E9%9A%94%E7%A6%BB%2012%E6%9C%8824%E6%97%A5-1%E6%9C%887%E6%97%A5/"},{"title":"Java常用工具包","text":"1、lombok 12345671.1 @Data1.2 @Get @Set1.3 @ToStrng1.4 @AllArgsConstructor @NoArgsConstrutor1.5 @Accessors //链式调用1.6 @Slf4j 2、hutool 12345672.1 hutool-convert 2.1.2 转换为字符串 Convert.toStr 2.1.3 转换为指定类型数组 Convert.toIntArray 2.1.4 转换为日期对象 Convert.toDate 2.1.5 转换为集合 Convert.toList2.1 hutool-IoUtil IoUtil.copy(is,os);","link":"/2021/01/22/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85/"},{"title":"Java并发编程","text":"待更新","link":"/2021/07/27/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"title":"Jenkins+svn+maven+sonarqube自动化部署总结","text":"Jenkins+svn+maven+sonarqube自动化部署总结 1、Jenkins安装与配置 1）Jenkins下载 2）Jenkins配置JDK与Maven等 2、svn与Jenkins集成 3、sonarqube安装及与Jenkins 集成 4、问题汇总 Caused by: org.tmatesoft.svn.core.SVNAuthenticationException: svn: E170001: Authentication required for ‘ 1、Jenkins安装与配置1）Jenkins下载12345678910 1)部署Jenkins 需要提前安装JDK 2)通过 weget http://mirrors.jenkins.io/war-stable/2.289.1/jenkins.war 下载jenkins war包直接丢到tomcat webapps下 3)修改tomcat下/conf/server.xml增加URIEncoding=&quot;UTF-8&quot;&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 72 connectionTimeout=&quot;20000&quot; 73 redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 4)通过http://地址:8080/jenkins 访问 Jenkins 主页,在启动之后Linux命令窗口 会有初始密码【要记住保存下来】 2）Jenkins配置JDK与Maven等1234要下载的插件 Subversion Plugin-in 整合svn的插件 Deploy to container 整合发布war包的 SonarQube Scanner 12345678910111213141516171819201) 查看密码【复制密码保存到txt中，之后要用到】 cat /root/.jenkins/secrets/initialAdminPassword2) 密码登录3) 插件安装 可以选择插件安装也可以不安装4) 登录 可以创建用户也可以右下角选择admin用户登录5) 全局安全配置 勾选 允许用户注册（这样即使忘记密码也可以注册）6) 全局工具配置 配置maven的settings.xml以及仓库 在Defalut settings provider 下选择 settings file in filesystem 在Defalut global settings provider 下选择 Global settings file on filesystem 在两个File path 填写settings.xml的文件路径以及该文件。($MAVEN_HOME)7) 设置JDK 起个别名（随便起） 取消自动安装，指定JAVA_HOME的路径 ($JAVA_HOME)8)设置Maven 起个别名 取消自动安装，指定MAVEN_HOME的路径 2、svn与Jenkins集成123456789101112在svn 目录上1)在conf里 编辑 svnserve.conf[解除注释及修改]anon-access = none auth-access = writepassword-db = passwdauthz-db = authz2) passwd 创建suman =1231233) authzsubman = rw * = 123456789101112131415161718192021Jenkins 新建任务 1) 取名字2) 源码管理 subversion下 Repository URL 下填写svn项目目录+工程目录+@HEAD Credentials add Jenkins 填写用户名 密码3)配置 构建下 增加构建步骤 Invoke top-level Maven targets Maven vesion 选择之前创建的maven 别名 Goals 填写 【clean install】 保存4)点击立即构建 尝试构建是否成功5) 构建触发器（开始配置 提交代码自动打包） 触发远程构建 http://192.168.70.131:8080/jenkins/job/项目名字/build？token=XXX_TOKEN svn项目仓库 hooks目录 编辑 post-commit.tml文件 curl -X post -v -u admin:2f6bff33bda14baba83ba1c002045f05 http://192.168.70.131:8080/jenkins/job/项目名/build?token=XXX_TOKEN 复制post-commit.tml 不要带tml 在最下面粘贴 3、sonarqube安装及与Jenkins 集成123456789101112131415161718191、安装数据库创建数据库 创建sonar 用户提高用户权限：chown -R sonar. /sonarcd confg sonar.properties 修改用户名密码 放开连接数据库信息以sonar 用户启动 sonar.sh start默认登录 admin admin输入字符 生成密钥并牢记保存。全局工具配置sonarqubeScanner取名字 自动安装configure system名字 证书 -&gt; 凭据 -&gt; jenkins 全局 -&gt;添加凭据 -&gt; 下拉密码文本 密钥+描述保存 12345678910111213141516171819【jenkins 配置sonarqube】# must be unique in a given SonarQube instancesonar.projectKey=parallel# this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6.1.sonar.projectName=parallelsonar.projectVersion=1.0# Path is relative to the sonar-project.properties file. Replace &quot;\\&quot; by &quot;/&quot; on Windows.# This property is optional if sonar.modules is set.sonar.sources=.sonar.exclusions=**/test/**,**/target/**sonar.java.binaries=target/classessonar.java.source=1.8sonar.java.target=1.8# Encoding of the source code. Default is default system encodingsonar.sourceEncoding=UTF-8sonar.projectVersion=${BUILD_NUMBER}//配置版本号，不然第一次提交正常，之后的提交显示错误 4、问题汇总Caused by: org.tmatesoft.svn.core.SVNAuthenticationException: svn: E170001: Authentication required for ‘svn://192.168.1.95:3690 6f205048-4e01-0010-937d-7723a8b4cf5f‘1234提示权限不足的问题 参考【1】1、打开sonarqube的控制台，使用admin登录后 ，在配置-&gt;SCM-&gt;菜单中，将Disabled the SCM Sensor设置为true，2、在svn页面，设置svn的用户名和密码。3、记得要保存一下，不然不生效。 jenkins构建失败解决办法参考【1】sonar-scanner扫描代码出错 SonarQube svn: E170001 sonarqube启动失败解决办法参考【1】SonarQube 搭建代码质量管理平台【2】SonarQube部署采坑 Jenkins定时构建【1】Jenkins定时构建 sonarqube插件导出报告【1】SonarQube 插件之 Issues Report &amp; SonarLint 的配置及使用【2】sonar获取多次版本号","link":"/2021/07/08/Jenkins+svn+maven+sonarqube%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%80%BB%E7%BB%93/"},{"title":"Linux下 jdk和tomcat等应用安装配置","text":"Linux下 jdk/tomcat等应用安装配置 1、JDK安装配置 2、tomcat安装配置 3、maven安装 1、JDK安装配置123456789101112131415161、解压安装包 tar -zxvf jdk安装包.tar.gz 2、配置环境变量 vim /etc/profile 在最后复制粘贴如下： export JAVA_HOME=/usr/local/java/jdk1.8.0_161export JRE_HOME=/$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin3、刷新文件 source /etc/profile4、查看是否配置成功 java -version jdk 2、tomcat安装配置123456前提：装好jdk1、解压 tar -zxvf tomctat安装包.tar.gz 2、启动 ./startup.sh 3、maven安装1234567891011121、解压文件 tar -zxvf apache-maven-3.6.1-bin.tar.gz2、配置环境变量 vim /etc/profile export MAVEN_HOME=/usr/local/apache-maven-3.6.1export PATH=$MAVEN_HOME/bin:$PATH 3、刷新文件 source /etc/profile4、查看版本 mvn -v","link":"/2021/07/19/Linux%E4%B8%8B%20jdk%E5%92%8Ctomcat%E7%AD%89%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"title":"Linux常用命令写法套路","text":"Linux常用命令写法套路 1、更改文件的名字 2、解压与压缩文件 3、删除文件 4、文件相关 5、权限管理 6、关于vim 7、更改linux语言环境 8、文件权限相关 9、密码 10、查看yum安装目录 11、ln建立软连接 12、时间相关命令 13、查看进程端口占用情况 14、查看日志命令 15、查看linux系统cpu核数 16、查找文件或文件夹 参考与扩展博客 1、更改文件的名字12mv test tttest为当前文件名称 tt为要改成的名字 2、解压与压缩文件1234567891011121314151617181920212223关于war包解压1）将文件解压到当前目录 （不推荐） jar -xvf test.war2）将文件解压到指定目录（解压到project文件夹）推荐 unzip project.war -d project 压缩1）将当前文件夹下所有文件打包成war包（推荐） jar -cvf myweb.war .2）将该project 文件夹打包成pp.war包（不推荐） jar -cvf pp.war project =====================================-c 创建war包-v 显示过程信息-f 指定 JAR 文件名，通常这个参数是必须的=====================================关于tar文件1)解压到指定目录tar -zxvf 文件名 -C /usr/local/unzip -d /usr/local test.zip 3、删除文件123456789101112131415161718反向删除前shopt -s extglob 进入该模式 不然!会找不到该命令shopt -s extglob #打开bash 识别正则shopt -u extglob #关闭bash 识别正则=====================================1）删除除keep文件之外的所有文件 rm -rf !(keep) 2）#删除keep1和keep2文件之外的所有文件 rm -rf !(keep1|keep2) |之间不能有空格 不然会全部删除 3）删除某些固定字母开头的文件 rm -rf xxx* 4)删除一类文件 rm -rf *.txt 5)删除多个文件 rm -rf t1 t2 t3 4、文件相关1234567891）创建多级目录mkdir -p test/t1/t22) 复制目录到 另一个文件夹下cp -r test /usr/local===============-r 递归复制目录mv tst.zip ../ #启动到上一层目录mv test.zip project/ #移动当前目录下的project目录 5、权限管理1234567891011给test用户提高 project文件夹权限chown -R test.test /project==================================-c或——changes：效果类似“-v”参数，但仅回报更改的部分；-f或--quite或——silent：不显示错误信息；-h或--no-dereference：只对符号连接的文件作修改，而不更改其他任何相关文件；-R或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；-v或——version：显示指令执行过程；--dereference：效果和“-h”参数相同；--reference=&lt;参考文件或目录&gt;：把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同；--version：显示版本信息。 6、关于vim12345678910111213141516171819202122232425262728293031321) 保存与不保存 :wq -保存文件，退出 vim (推荐) :wq! -强制保存文件，退出 vim :q -不保存文件，退出 vim (推荐) :q! -不保存文件，强制退出 vim===============================2) 整页翻页 ctrl-f ctrl-b (f就是forword b就是backward)3)跳转到最后一行 shift+g 跳转到第一行 gg 4) 替换文件中的字符串 sed -i 's/343/209/g' application.yml譬如修改 配置文件中的端口号 将343改为209 5) 向下复制一行 非编辑模式下 按&quot;yy&quot;,再&quot;p&quot;6) 快速移动至行首 home shift + 6 (只有非编辑模式可)7) 快速移动至行尾 end shift + 4 (只有非编辑模式可)8) 撤销上一步 u (非编辑模式) 9） 查找文件中字符串 1、命令模式下输入“/120”，例如“/120”。 2、如果查找下一个，按“n”即可。 7、更改linux语言环境123456789101、先输出一下当前文件环境 echo $LANG 2、查看语言包locale -a (zh_CN.UTF-8是简体中文)没有直接安装 yum install kde-l10n-Chinese3、修改配置文件 vim /etc/locale.conf ##将第一行，设置中文 改为 LANG=zh_CN.UTF-8 8、文件权限相关chmod修改文件权限 1234chmod 774 test.sh // u=rwx,g=rw,o=rchmod 764 test.shchmod 754 test.sh // 推荐chmod 744 test.sh 9、密码passwd 10、查看yum安装目录121. rpm -qa|grep [keyname] 查看带有name名称的软件。2. rpm -ql [name]。查看该软件的安装目录 11、ln建立软连接123456789ln [参数][源文件或目录][目标文件或目录]必要参数:-b 删除，覆盖以前建立的链接-d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程 12、时间相关命令121、与NTP服务器(上海) 同步服务器时间ntpdate -u ntp.api.bz 12345678910ntp常用服务器：中国国家授时中心：210.72.145.44NTP服务器(上海) ：ntp.api.bz美国： time.nist.gov复旦： ntp.fudan.edu.cn微软公司授时主机(美国) ：time.windows.com北京邮电大学 : s1a.time.edu.cn清华大学 : s1b.time.edu.cn北京大学 : s1c.time.edu.cn台警大授时中心(台湾)：asia.pool.ntp.org 13、查看进程端口占用情况12345678netstat -tunlpnetstat -tunlp | grep 8000=================================t：表示查看tcpu：表示查看udpp：表示占用端口的进程n：表示端口以数字形式表示，没有n直接显示服务名l：表示显示所监听的端口 14、查看日志命令1234567891011tail: -n 是显示行号；相当于nl命令; tail -100f test.log 实时监控100行日志 tail -n 10 test.log 查询日志尾部最后10行的日志; tail -n +10 test.log 查询10行之后的所有日志; head: 与tail是相反的，tail是看后多少行日志，head查看前面日志 head -n 10 test.log 查询日志文件中的头10行日志; head -n -10 test.log 查询日志文件除了最后10行的其他所有日志; cat： cat从前往后显示文本文件内容,tac与cat相反，从后往前显示文本文件内容 cat -n test.log |grep &quot;debug&quot; 查询关键字的日志 应用场景 1234567891011121314151617180、从最后快速往前查找每页 前后翻页【推荐】 cat -n /usr/local/xx.log | less 然后shift+g 到最后一行 按b 往前翻页 按f 往后翻页 按j 向后滚动一行 按k 向前移动一行1、根据日期查询日志 sed -n '/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p' test.log 特别说明:上面的两个日期必须是日志中打印出来的日志,否则无效； 先 grep '2014-12-17 16:17:20' test.log 来确定日志中是否有该 时间点more命令好像只能完后翻页，不能往前翻【待探讨】2、日志内容特别多，打印在屏幕上不方便查看 (1)使用more和less命令, 如： cat -n test.log |grep &quot;debug&quot; |more 这样就分页打印了,通过点击空格键翻页 (2)使用 &gt;xxx.txt 将其保存到文件中,到时可以拉下这个文件分析 如：cat -n test.log |grep &quot;debug&quot; &gt;debug.txt 15、查看linux系统cpu核数12345678查看物理CPU个数cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq逻辑CPU的个数 ，这个是我们的机器总的cpu的个数，也是设置线程池大小的时候考虑的cpu的个数。cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l 12345678910111213141516lscpu-------------------------Architecture: i686 #架构686CPU(s): 2 #逻辑cpu颗数是2Thread(s) per core: 1 #每个核心线程数是1 Core(s) per socket: 2 #每个cpu插槽核数/每颗物理cpu核数是2CPU socket(s): 1 #cpu插槽数是1Vendor ID: GenuineIntel #cpu厂商ID是GenuineIntelCPU family: 6 #cpu系列是6Model: 23 #型号23Stepping: 10 #步进是10CPU MHz: 800.000 #cpu主频是800MHzVirtualization: VT-x #cpu支持的虚拟化技术VT-x(对此在下一博文中解释下http://hi.baidu.com/sdusoul/blog/item/5d8e0488def3a998a5c272c0.html)L1d cache: 32K #一级缓存32K（google了下，这具体表示表示cpu的L1数据缓存为32k）L1i cache: 32K #一级缓存32K（具体为L1指令缓存为32K）L2 cache: 3072K #二级缓存3072K 16、查找文件或文件夹123456789101112131415(1)find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 (2)grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。(3)which 查看可执行文件的位置 ，只有设置了环境变量的程序才可以用(4)whereis 寻找特定文件，只能用于查找二进制文件、源代码文件和man手册页(5)locate 配合数据库查看文件位置 ,详情：locate -h查看帮助信息find: 语法格式：find 搜索路径 [选项] 搜索内容选项：-name: 按照文件名搜索； -iname: 按照文件名搜索，不区分文件名大小；常用案例： find / -name yum.conf 参考与扩展博客【1】Linux学习手册大全【2】Linux服务器时间同步【3】linux less从后向前查看日志信息【4】Linux查看日志常用命令【5】Linux下如何查看CPU信息【6】线程池（3）设置线程池大小和linux 查看cpu核数","link":"/2021/07/08/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%86%99%E6%B3%95%E5%A5%97%E8%B7%AF/"},{"title":"MyCat的基本使用总结","text":"待更新","link":"/2021/07/31/MyCat%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"MySQL中的锁","text":"MySQL中的锁 一、全局锁 1）语法 2）注意点和存在的问题 二、表级锁 1）表锁 2）元数据锁（meta data lock，MDL） 3）意向锁 三、行级锁 1）行锁 2）间隙锁&amp;临键锁 预备知识：SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。DQL （Data Query Language） 数据查询语言，用来查询数据库中表的记录DDL （Data Definition Language） 数据定义语言，用来定义数据库对象(数据库，表，字段)DML（Data Manipulation Language）数据操作语言，用来对数据库表中的数据进行增删改DCL （Data Control Language） 数据控制语言，用来创建数据库用户、控制数据库的访问权限 锁是计算机协调多个进程或线程并发访问某一资源的机制。MySQL中的锁，按照锁的粒度分，分为以下三类： 全局锁：锁定数据库中的所有表。 表级锁：每次操作锁住整张表。 行级锁：每次操作锁住对应的行数据。 一、全局锁典型的使用场景是做全库的逻辑备份，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语 句，已经更新操作的事务提交语句都将被阻塞。 1）语法1). 加全局锁 1flush tables with read lock ; 2). 数据备份 1mysqldump -uroot –p1234 itcast &gt; goods.sql 3). 释放锁 1unlock tables ; 2）注意点和存在的问题主从情况下：1、如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。2、如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。 在InnoDB引擎中，可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致 性数据备份。--single-transaction 底层是通过快照读来实现的 1mysqldump --single-transaction -uroot –p123456 itcast &gt; goods.sql 二、表级锁应用在MyISAM、 InnoDB、BDB等存储引擎中。主要分为以下三类： 1、表锁 2、元数据锁（meta data lock，MDL） 3、意向锁 1）表锁分类对于表锁分为两类：表共享读锁（read lock）表独占写锁（write lock） 语法加锁：lock tables 表名… read/write。 lock tables goods read/write释放锁：unlock tables 或者 客户端断开连接 。unlock tables 读锁对指定表加了读锁所有客户端都可以读；所有客户端都不可以写 ，包括当前客户端 写锁只有当前客户端可读可写，其他客户端都不可以进行读写操作 2）元数据锁（meta data lock，MDL）meta data lock , 元数据锁，简写MDL。MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。 为了避免DML与 DDL冲突，保证读写的正确性。 查看数据库中的元数据锁 1select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ; 3）意向锁意向锁所解决的问题如果没有意向锁：客户端一 对表加了行锁后，客户端二 给表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。有意向锁后：客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。 1主要是来解决 行锁与表锁之间，冲突与判断的效率。 分类：意向共享锁(IS): 由语句select ... lock in share mode添加 。 与表锁-读锁兼容，与表锁-写锁互斥。意向排他锁(IX): 由insert、update、delete、select...for update添加 。与表锁-读锁 和 写锁都互斥，意向锁之间不会互斥。 一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。 查看意向锁及行锁的加锁情况： 1select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; 三、行级锁行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。 InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。主要分为三类：行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。 1）行锁共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。 也就是说：一个事务加了共享锁，只兼容其他事务的共享锁。一个事务加了排它锁，其他都不行，都会排斥。 sql语句中：insert update delete 增删改 加的排它锁 是自动加锁select ... for update 加的排他锁 select 不加任何锁select ... lock in share mode 加的共享锁 结合表级锁-意向锁来看，注意这里不要搞混select ... lock in share mode 加的行级锁-行锁-共享锁 和 表级锁-意向锁-意向共享锁insert update delete select ... for update 加行级锁-行锁-排它锁 和 表级锁-意向锁-意向排它锁 注意：默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。 查看意向锁及行锁的加锁情况： 1select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks; 2）间隙锁&amp;临键锁默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。1、索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。2、索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。3、索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。 注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁。 A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。 B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。","link":"/2022/04/11/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/"},{"title":"MySQL事务","text":"MySQL事务 1、数据库事务ACID 2、数据库的四个隔离级别 2.1 不可重复读和幻读的区别 参考博客 1、数据库事务ACID1234原子性：要么都执行，要么都回滚一致性：保证数据的状态操作前和操作后保持一致隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改。 2、数据库的四个隔离级别123456789设置事务的隔离级别 1、READ UNCOMMITTED 2、READ COMMITTED 可以避免脏读 3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读 4、SERIALIZABLE可以避免脏读、不可重复读和幻读 脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据 2.1 不可重复读和幻读的区别12不可重复读 主要是说多次读取一条记录, 发现该记录中某些列值被修改过。幻读 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。 参考博客【1】【数据库】快速理解脏读、不可重复读、幻读【2】 搞懂 不可重复读和幻读","link":"/2021/07/12/MySQL%E4%BA%8B%E5%8A%A1/"},{"title":"MySQL索引基本操作及说明","text":"MySQL索引基本操作及说明 1、索引基本操作 2、什么时候创建索引? 2.1 哪些情况需要创建索引? 2.2 哪些情况不需要创建索引? 3、分析sql语句之explain 4、查询优化的原则 1、索引基本操作123查看索引： show index from user_auth创建索引： create unique index [索引名字] on [表名字] (字段)删除索引： drop index [索引名字] from [表名字] 2、什么时候创建索引?2.1 哪些情况需要创建索引?1234561、主键自动建立唯一索引2、频繁作为查询条件的字段应该创建索引3、查询中与【其它表关联的字段】，外键关系建立索引4、单键/组合索引的选择问题， 组合索引性价比更高5、查询中【排序的字段】，排序字段若通过索引去访问将大大提高排序速度6、查询中【统计或者分组字段】 2.2 哪些情况不需要创建索引?12341、表记录太少2、经常增删改的表或者字段3、Where条件里用不到的字段不创建索引4、过滤性不好(如性别 男 女)的不适合建索引 3、分析sql语句之explain123456789101112131415161718id：SQL语句中表的读取顺序 id相同：执行顺序为 从上至下执行 id不同：执行顺序为 id大的先执行select_type：查询操作类型 主要是用于区别普通查询、联合查询、子查询等的复杂查询table：表的来源 *type：访问类型 (重点) 是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏依次是： --常见的顺序为 system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all 一般来说，得保证查询 至少达到 range 级别，最好能达到 ref possible_key：可能用到的索引 key_len：索引使用字节数 ken_len 越长，说明索引使用的越充分 ref：显示被使用的索引的具体信息 rows：被查询的行数 rows 列显示 MySQL 认为它执行查询时必须检查的行数。越少越好！ Extra：额外重要信息 Using filesort：使用外部索引排序（未使用用户创建的索引） 4、查询优化的原则123456789101112一、单表查询优化 1、全值匹配我最爱 建立复合索引 都建上 2、最佳左前缀法则：即最左优先，在检索数据时从联合索引的最左边开始匹配。 3、索引列上进行 (计算、函数、(自动 or 手动)类型转换), 索引失效 4、范围之后全失效 (索引范围右边的字段 全失效) &gt; &lt; 5、使用不等会失效 6、使用NULL值要小心 is not null (使用负面的 如不等于 not null 都会失效) 7、模糊查询加右边 like'%asdsad%'会因左边%失效 8、字符串加单引号（类型转换失效）============================================================================= 8、覆盖索引多使用 10、尽量不用or查询 12345678910二、关联查询数据优化 两个表关联查询 第一个表叫驱动表 第二个叫被驱动表 避免不了总有一个全表扫描 一张表数据量大，一张表数据量小，把小表放在驱动表 （物理扫描行要少） 1、保证被驱动表join字段已经被建立索引 2、left join选择小表作为驱动表 大表作为被驱动表 3、inner join mysql 自己会帮你把小结果集作为驱动表 4、子查询尽量不要放在被驱动表，子查询为虚拟表，用不了索引 5、能直接关联尽量直接关联，不要用子查询。 12三、子查询优化 尽量不要用not in 或者 not exists 1234四、分组查询优化 无过滤，不索引 顺序错，必排序 方向反，必排序 要么升序 要么都降序","link":"/2021/07/11/MySQL%E7%B4%A2%E5%BC%95%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8F%8A%E8%AF%B4%E6%98%8E/"},{"title":"Mysql数据库表设计用int还是Integer","text":"数据库表设计用int还是Integer？代码中实体类用int还是Interger","link":"/2021/04/11/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1%E7%94%A8int%E8%BF%98%E6%98%AFInteger/"},{"title":"Postgresql基本操作","text":"1、卸载postgresql 12345678910111213141516 1) yum 删除软件包： yum remove postgresql* 或者 rpm -qa | grep postgres 查看一下，再将查出来的 写道下面一行postgresql 替换掉 rpm -e postgresql --nodeps 2) 删除相关目录文件： rm -rf /var/lib/pgsql rm -rf /usr/pgsql* 3) 删除pg相关用户组/用户userdel -r postgresgroupdel postgres 4) 删除data数据rm -rf /data/pgsql 2、启动postgresql 1/usr/local/pgsql/bin/pg_ctl -D /data/pgsql/data/ start 3、停止posgresql 1/usr/local/pgsql/bin/pg_ctl -D /data/pgsql/data/ stop 4、数据备份与恢复 12345导出库表pg_dump -h localhost -U postgres geThirdRepo&gt; dum.sql导入库表psql -U postgres geThirdRepo &lt; post.sql","link":"/2021/07/05/Postgresql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"Postman中文设置","text":"打开Postman目录 找到如app-8.8.6/resources下 将app.zip文件解压到该文件夹下即可 重新打开postman 即可 123app.zip文件下载链接如下：链接：https://pan.baidu.com/s/1-9YyWGR9Ys6ugZDbB-ohVg 提取码：vayo","link":"/2021/07/09/Postman%E4%B8%AD%E6%96%87%E8%AE%BE%E7%BD%AE/"},{"title":"Postman同时上传多个文件和数据","text":"定义对象，对象重要包含数组，而不是写成List1、对象 12345public class FileDataList(){ String names[]; String sizes[]; MultipartFile files[];} 2、Controller 123public void sendData(FileDataList filedatas){} 3、postmanBody下的form-data传参数和文件，传多个参数和文件就往下面写每个key要一样，如： 123456names 测试文件01sizes 10files xx.pngnames 测试文件02sizes 15files xxx.png","link":"/2021/08/06/Postman%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E5%92%8C%E6%95%B0%E6%8D%AE/"},{"title":"RocketMQ-broker.conf 配置文件","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# Licensed to the Apache Software Foundation (ASF) under one or more# contributor license agreements. See the NOTICE file distributed with# this work for additional information regarding copyright ownership.# The ASF licenses this file to You under the Apache License, Version 2.0# (the &quot;License&quot;); you may not use this file except in compliance with# the License. You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.​​# 所属集群名字brokerClusterName=DefaultCluster​# broker 名字，注意此处不同的配置文件填写的不一样，如果在 broker-a.properties 使用: broker-a,# 在 broker-b.properties 使用: broker-bbrokerName=broker-a​# 0 表示 Master，&gt; 0 表示 SlavebrokerId=0​# nameServer地址，分号分割# namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876​# 启动IP,如果 docker 报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;192.168.0.120:10909&gt; failed# 解决方式1 加上一句 producer.setVipChannelEnabled(false);，解决方式2 brokerIP1 设置宿主机IP，不要使用docker 内部IPbrokerIP1=192.168.200.129​# 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数defaultTopicQueueNums=4​# 是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭 autoCreateTopicEnable=true​# 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup=true​# Broker 对外服务的监听端口listenPort=10911​# 删除文件时间点，默认凌晨4点deleteWhen=04​# 文件保留时间，默认48小时fileReservedTime=120​# commitLog 每个文件的大小默认1GmapedFileSizeCommitLog=1073741824​# ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整mapedFileSizeConsumeQueue=300000​# destroyMapedFileIntervalForcibly=120000# redeleteHangedFileInterval=120000# 检测物理文件磁盘空间diskMaxUsedSpaceRatio=88# 存储路径# storePathRootDir=/home/ztztdata/rocketmq-all-4.1.0-incubating/store# commitLog 存储路径# storePathCommitLog=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/commitlog# 消费队列存储# storePathConsumeQueue=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/consumequeue# 消息索引存储路径# storePathIndex=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/index# checkpoint 文件存储路径# storeCheckpoint=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/checkpoint# abort 文件存储路径# abortFile=/home/ztztdata/rocketmq-all-4.1.0-incubating/store/abort# 限制的消息大小maxMessageSize=65536​# flushCommitLogLeastPages=4# flushConsumeQueueLeastPages=2# flushCommitLogThoroughInterval=10000# flushConsumeQueueThoroughInterval=60000​# Broker 的角色# - ASYNC_MASTER 异步复制Master# - SYNC_MASTER 同步双写Master# - SLAVEbrokerRole=ASYNC_MASTER​# 刷盘方式# - ASYNC_FLUSH 异步刷盘# - SYNC_FLUSH 同步刷盘flushDiskType=ASYNC_FLUSH​# 发消息线程池数量# sendMessageThreadPoolNums=128# 拉消息线程池数量# pullMessageThreadPoolNums=128","link":"/2021/07/10/RocketMQ-broker.conf%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"title":"RocketMQ-docker-compose.yml配置","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657version: '3.5'services: rmqnamesrv: image: foxiswho/rocketmq:server container_name: rmqnamesrv ports: - 9876:9876 volumes: - ./data/logs:/opt/logs - ./data/store:/opt/store networks: rmq: aliases: - rmqnamesrv​ rmqbroker: image: foxiswho/rocketmq:broker container_name: rmqbroker ports: - 10909:10909 - 10911:10911 volumes: - ./data/logs:/opt/logs - ./data/store:/opt/store - ./data/brokerconf/broker.conf:/etc/rocketmq/broker.conf environment: NAMESRV_ADDR: &quot;rmqnamesrv:9876&quot; JAVA_OPTS: &quot; -Duser.home=/opt&quot; JAVA_OPT_EXT: &quot;-server -Xms128m -Xmx128m -Xmn128m&quot; command: mqbroker -c /etc/rocketmq/broker.conf depends_on: - rmqnamesrv networks: rmq: aliases: - rmqbroker​ rmqconsole: image: styletang/rocketmq-console-ng container_name: rmqconsole ports: - 8080:8080 environment: JAVA_OPTS: &quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; depends_on: - rmqnamesrv networks: rmq: aliases: - rmqconsole​networks: rmq: name: rmq driver: bridge","link":"/2021/07/10/RocketMQ-docker-compose.yml%E9%85%8D%E7%BD%AE/"},{"title":"RocketMQ基本安装与使用","text":"RocketMQ基本安装与使用 1、安装与配置 1.1下载安装 1.2 配置 1.2.1 创建docker-compose.yml文件 1.2.2 创建broker.conf 配置 1.2.3 启动与停止 异常情况处理 1、安装与配置1.1下载安装123456curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose #查看是否安装成功docker-compose --version 1.2 配置1.2.1 创建docker-compose.yml文件123456781：创建文件夹：rocketmqmkdir rocketmq2：进入rocketmqcd rocketmq3：使用vim命令编辑docker-compose.yml文件vim docker-compose.yml 并填充如下内容：【点击查看docker-compose.yml配置】 1.2.2 创建broker.conf 配置123456783：在该目录下创建broker的配置文件目录mkdir -p data/brokerconf cd data/brokerconf vim broker.conf4：RocketMQ Broker 需要一个配置文件，按照上面的 Compose 配置，我们需要在 ./data/brokerconf/ 目录下创建一个名为 broker.conf 的配置文件 并填充如下内容：【点击查看broker.conf 配置】 1.2.3 启动与停止123456789105：回到docker-compose.yml配置文件所在目录启动docker-compose -f docker-compose.yml up -d启动后查看docker容器是否创建并启动docker ps如果想停止容器的运行，使用如下compose命令docker-compose stop6：访问RocketMQ管理控制台界面，访问地址：http://地址:8080/ 异常情况处理com.alibaba.rocketmq.remoting.exception.RemotingConnectException 1234启动IP,如果 docker 报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;192.168.0.120:10909&gt; failed解决方式1 加上一句 producer.setVipChannelEnabled(false);解决方式2 brokerIP1 设置宿主机IP，不要使用docker 内部IP brokerIP1=换成自己的IP RocketMQ：closeChannel: close the connection to remote address[] result: true 1控制台打印如上情况，记得开启云服务器9876、10909、10911、10912 端口","link":"/2021/07/10/RocketMQ%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"Sharding-JDBC的基本介绍使用","text":"Sharding-JDBC的基本介绍使用 1、基本概念介绍 1.1 逻辑表 1.2 真实表 1.3 数据节点 1.4 分配策略 2、使用步骤 1、在pom文件中引入依赖 2、分库分表sql脚本导入 3、数据源整合 1、基本概念介绍1.1 逻辑表是对于水平拆分的数据库（表）的同一类表的总称。例如：订单数据根据主键尾数拆分为10张表，分别是t_order_0到t_order_9，他们的逻辑表可以表示为t_order，在应用程序中操作的是逻辑表。 1.2 真实表在分片的数据库中真实存在的物理表。即上个示例中的t_order_0到t_order_9。 1.3 数据节点数据分片的最小单元, 由数据源名称和数据表组成 例如：db_0.t_order_0。 表示 数据库db_0下名称为t_order_0的表 1.4 分配策略以下五种分配策略：StandardShardingStrategy：标准分片策略。提供对SQL语句中的=, IN和BETWEEN AND的分片操作支持。只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。 InlineShardingStrategy：Inline表达式分片策略。使用Groovy的Inline表达式，提供对SQL语句中的=和IN的分片操作支持。 HintShardingStrategy：通过Hint而非SQL解析的方式分片的策略。 NoneShardingStrategy：不分片的策略 自定义分片策略 2、使用步骤1、在pom文件中引入依赖2、分库分表sql脚本导入3、数据源整合以往我们都是配置唯一数据源，但是现在要连接多个数据库，所以要配置多个数据源与以往不同部分的配置1）配置yml文件 123456789101112131415shardingsphere: datasource: ds0: driver-class-name: com.mysql.cj.jdbc.Driver password: 123456 type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://192.168.201.129:3306/schedule0?serverTimezone=Asia/Shanghai username: root ds1: driver-class-name: com.mysql.cj.jdbc.Driver password: 123456 type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://192.168.201.129:3306/schedule1?serverTimezone=Asia/Shanghai username: root names: ds0,ds1 2）修改启动配置类在启动类：ScheduleApplication 上将系统默认spring的数据源自动配置类排除 123456//@SpringBootApplication@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})......public class ScheduleApplication { ..........} 3）集成shardingDataSource数据源创建MybatisPlusShardingConfiguration 配置类，将shardingDataSource数据源集成到mybatis-plus中去 12345678910111213141516/** *mybatis-plus 使用sharding-jdbc数据源问题 */@Configuration@AutoConfigureAfter(DataSource.class)public class MybatisPlusShardingConfiguration { //获取sharding 数据源 @Autowired private DataSource dataSource; @Bean public MybatisSqlSessionFactoryBean mybatisSqlSessionFactoryBean(){ MybatisSqlSessionFactoryBean mysqlplus = new MybatisSqlSessionFactoryBean(); mysqlplus.setDataSource(dataSource); return mysqlplus; }} 4）完善yml分配策略 123456789101112131415sharding: tables: taskinfo: actual-data-nodes: ds$-&gt;{0..1}.taskinfo_$-&gt;{0..1} key-generator: #主键生成策略 column: task_id type: SNOWFLAKE database-strategy: #分库策略 inline: sharding-column: task_type algorithm-expression: ds$-&gt;{task_type % 2} table-strategy: #分表策略 inline: sharding-column: priority algorithm-expression: taskinfo_$-&gt;{priority % 2}","link":"/2021/07/31/Sharding-JDBC%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E4%BD%BF%E7%94%A8/"},{"title":"SpringBoot-延迟任务的基本使用","text":"待更新 参考博客【1】SpringBoot三种方式实现定时任务 【2】Spring项目启动完成后，自动执行一次指定方法 【3】SpringBoot之ApplicationRunner（一个spring容器启动完成执行的类）","link":"/2021/07/26/SpringBoot-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"Springboot中RestTemplate使用总结","text":"1、RestTemplate基本使用RestTemplate的POST请求常用的两个主要方法为：1、postForObject()2、postForEntity() 二者的主要区别：postForObject()返回值是HTTP协议的响应体。postForEntity()返回的是ResponseEntity，ResponseEntity是对HTTP响应的封装，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息。 postForObject的用法 1234567891011121314// 请求地址 String url = &quot;http://jsonplaceholder.typicode.com/posts&quot;; // 请求头设置,x-www-form-urlencoded格式的数据 HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED); //提交参数设置 MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;&gt;(); map.add(&quot;title&quot;, &quot;zimug 发布文章第二篇&quot;); map.add(&quot;body&quot;, &quot;zimug 发布文章第二篇 测试内容&quot;); // 组装请求体 HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; request = new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(map, headers); // 发送post请求，并打印结果，以String类型接收响应结果JSON字符串 String result = restTemplate.postForObject(url, request, String.class); System.out.println(result); postForEntity的用法 1234567891011HttpHeaders headers = new HttpHeaders();MediaType type = MediaType.parseMediaType(&quot;multipart/form-data&quot;);// 设置请求的格式类型headers.setContentType(type);FileSystemResource fileSystemResource = new FileSystemResource(path);MultiValueMap&lt;String, Object&gt; form = new LinkedMultiValueMap&lt;&gt;();form.add(&quot;name&quot;, fileSystemResource);HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; files = new HttpEntity&lt;&gt;(form, headers);ResponseEntity&lt;TopicFileResponse&gt; responseResponseEntity = restTemplate.postForEntity(url, files, TopicFileResponse.class);TopicFileResponse body = responseResponseEntity.getBody();return body; 参考博客【1】精讲RestTemplate第4篇-POST请求方法使用详解【2】使用restTemplate上传文件MultipartFile","link":"/2021/08/03/Springboot%E4%B8%ADRestTemplate%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"Springboot中线程池的使用与应用","text":"Springboot中线程池的使用与应用 1、线程池的类型 2、TaskExecutor接口的实现类简要说明 3、自定义ThreadPoolTaskExecutor 1）配置 2）使用 1、线程池的类型1：Executors.newSingleThreadExecutor()corePoolSize和maximumPoolSize都为1，也就是创建了一个固定大小是1的线程池，workQueue是new LinkedBlockingQueue &lt; Runnable &gt;()是一种无界阻塞队列，队列的大小是Integer.MAX_VALUE，可以认为是队列的大小不限制。由此可以得出通过该方法创建的线程池，每次只能同时运行一个线程，当有多个任务同时提交时，那也要一个一个排队执行 2：Executors.newFixedThreadPool(int nThreads)创建了一个固定大小的线程池，可以指定同时运行的线程数量为nThreads。3：Executors.newCachedThreadPool()构造一个缓冲功能的线程池，配置corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，keepAliveTime=60s,以及一个无容量的阻塞队列 SynchronousQueue，因此任务提交之后，将会创建新的线程执行；线程空闲超过60s将会销毁4：Executors.newScheduledThreadPool(int corePoolSize)构造有定时功能的线程池，配置corePoolSize，无界延迟阻塞队列DelayedWorkQueue；maximumPoolSize=Integer.MAX_VALUE，由于DelayedWorkQueue是无界队列，所以这个值是没有意义的 2、TaskExecutor接口的实现类简要说明1：SimpleAsyncTaskExecutor类 ：这个实现不重用任何线程，或者说它每次调用都启动一个新线程，性能消耗比较严重。 2：ConcurrentTaskExecutor 类 ：Spring 2.x借助ConcurrentTaskExecutor和ThreadPoolTaskExecutor能够通过IoC配置形式自定义它们暴露的各个属性。很少需要使用ConcurrentTaskExecutor,有另一个备选, ThreadPoolTaskExecutor类 3：ThreadPoolTaskExecutor 类 ：ThreadPoolTaskExecutor内部对ThreadPoolExecutor进行了包装，同时提供能够通过IOC的形式来配置线程池的各个参数，比较常用 4：ThreadPoolTaskScheduler类 ：ThreadPoolTaskScheduler内部对ScheduledThreadPoolExecutor进行了包装，除了能执行异步任务外支持定时/延迟任务的执行，属于一种高级特性 3、自定义ThreadPoolTaskExecutor1）配置@Configuration 12345678910111213141516171819@Bean public ThreadPoolTaskExecutor mythreadpool(){ ThreadPoolTaskExecutor threadPool = new ThreadPoolTaskExecutor(); //设置核心线程数 threadPool.setCorePoolSize(5); //设置最大线程数 threadPool.setMaxPoolSize(100); //设置线程超时等待时间 threadPool.setKeepAliveSeconds(60); //设置任务等待队列的大小 threadPool.setQueueCapacity(100); //设置线程池内线程的名称前缀---阿里编码规约推荐----出错了方便调试 threadPool.setThreadNamePrefix(&quot;myThreadPool-&quot;); //设置任务拒绝策略 threadPool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); //直接初始化 threadPool.initialize(); return threadPool; } 2）使用123// @Autowired@Resource(name = &quot;mythreadpool&quot;)private ThreadPoolTaskExecutor threadPoolTaskExecutor;","link":"/2021/07/26/Springboot%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"title":"Springboot事务不生效的几种情况","text":"Springboot事务不生效的几种情况 【情况1】：确认创建的mysql数据库表引擎是InnoDB，MyISAM不支持事务​【情况2】：注解到protected，private 方法上，事务不生效，它也不会报错，不过事务设置不会起作用。​【情况3】： 在业务层捕捉异常后未向上抛出，事务不生效。【原因】：在业务层手工捕捉并处理了异常（try…catch）等于把异常“吃”掉了，Spring自然不知道这里有错，更不会主动去回滚数据。推荐做法是在业务层统一抛出异常，然后在控制层统一处理。​【情况4】：遇到非检测异常时，事务不开启，也无法回滚。原因：因为Spring的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。如果想针对非检测异常进行事务回滚，可以在@Transactional 注解里使用rollbackFor 属性明确指定异常。​【情况5】：不要写到接口上，spring 采用 aop 针对具体实现类做的代理实现。​【情况6】：Spring的事务传播策略在内部方法调用时将不起作用，事务注解加到要调用方法上。","link":"/2021/07/26/Springboot%E4%BA%8B%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/"},{"title":"Springboot拦截器配置","text":"待更新","link":"/2021/07/12/Springboot%E6%8B%A6%E6%88%AA%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"docker-compose命令与操作","text":"docker-compose命令与操作 一、docker-compose主要基本命令 二、docker-compose基本命令模板 三、docker-compose build指令 四、docker-compose 指令 五、docker可视化工具 portainer 一、docker-compose主要基本命令1）image 指定镜像 1image: tomcat:8 2）ports 端口映射 12ports: #宿主机：容器 - &quot;8080:8080&quot; 3）volumes 挂载数据卷 123volumes: #- /root/webapp:/root/web - tomcat:/root/web 注意：挂载数据卷，若不是写的宿主机绝对路径，要在下面写上定义目录。若使用自定义数据卷，还有通过external，来表示为true，并提前创建好目录 1234volumes: #定义目录 在之前加入项目名字 tomcat: external: #使用自定义卷名 提前创建目录 true 4）networks 指定网桥 12networks: # 指定网桥 -ems 5）container-name 指定容器名称 1container-name: mysql 6）command 覆盖容器默认命令覆盖容器内容的默认命令 CMD的命令 1command: &quot;redis-server --appendonly yes&quot; #覆盖容器内容的默认命令 7）environment 指定变量环境如指定mysql登录密码 12environment: - MYSQL_ROOT_PASSWORD=root 8）env_file 从文件中获取变量将6里面的MYSQL_ROOT_PASSWORD=root 可以写到配置文件中 如secrect.env，使得从配置文件中读取环境变量，解耦合。 12env_file : - ./webapps/secrect.env 9）depend_on 依赖容器一个容器依赖其他容器，这样先启动其他容器。 1234depend_on : - db #写服务id - redis - tomcat 10）healthcheck 健康检查容器运行状态进行检查 123456#在1m30s内 超时时间10s 重试3次healthcheck : test: [&quot;CMD&quot;,&quot;curl&quot;,&quot;-f&quot;,&quot;http://localhost&quot;] interval: 1m30s timeout: 10s retries: 3 11）sysctls 配置容器内核参数 123sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0 12）ulimits 指定容器进程数 12345ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 二、docker-compose基本命令模板1docker-compose up 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061version: '3'services: tomcat: #服务id唯一 container-name: tomcat image: tomcat:8 #创建当前服务所使用的镜像 ports: #宿主机：容器 - &quot;8080:8080&quot; volumes: #- /root/webapp:/root/web - tomcat:/root/web networks: # 指定网桥 -ems tomcat02: #服务名唯一 container-name: tomcat #指定容器名字 image: tomcat:8 #创建当前服务所使用的镜像 ports: #宿主机：容器 - &quot;8081:8080&quot; volumes: #- /root/webapp:/root/web - tomcat02:/root/web networks: -ems mysql: image: mysql:5.7 container-name: mysql ports: - &quot;3306:3306&quot; volumes: - mysqldata:/var/lib/mysql - mysqlconf:/etc/mysql environment: - MYSQL_ROOT_PASSWORD=root networks: hello redis: image: redis:5.0.10 container-name: redis ports: - &quot;6379:6379&quot; volumes: - redisdata:/data networks: hello command: &quot;redis-server --appendonly yes&quot; #覆盖容器内容的默认命令volumes: #定义目录 在之前加入项目名字 tomcat: external: #使用自定义卷名 提前创建目录 true tomcat02: mysqldata: mysqlconf: redisdata: networks: hello external: #使用自定义网桥 提前创建网桥 true 三、docker-compose build指令作用：指定dockerfile 打包对应的镜像 123456789101112demo: build: #先根据dockerfile 创建镜像 context: ./demo #指定上下文目录 当前目录 context: /usr/local/demo #指定上下文目录 dockerfil: Dockerfile container_name: demo ports: -8080:8080 networks: -ems depend_on: -tomcat 四、docker-compose 指令1）up 1234docker-compose -f xxx up-f 指定文件名-p 指定项目名称 在创建数据卷什么的基于该名-verbose 输出调试信息 2）down 1docker-compose down # 移除容器 并移除网络和容器内部数据卷 3）restart 12docker-compose restart [指定容器名]-t 指定超时时间 4）rm 123docker-compose rm [指定容器名]-f 强制删除 -v 删除挂载卷 5）stop 6）top 查看容器运行进程 7）pause/unpause暂停服务 / 恢复出于暂停状态中的服务 12345678910111213141516171819202122232425build Build or rebuild servicesbundle Generate a Docker bundle from the Compose fileconfig Validate and view the Compose filecreate Create servicesdown Stop and remove containers, networks, images, and volumesevents Receive real time events from containersexec Execute a command in a running containerhelp Get help on a commandimages List imageskill Kill containerslogs View output from containerspause Pause servicesport Print the public port for a port bindingps List containerspull Pull service imagespush Push service imagesrestart Restart servicesrm Remove stopped containersrun Run a one-off commandscale Set number of containers for a servicestart Start servicesstop Stop servicestop Display the running processesunpause Unpause servicesup Create and start containers ================================================================================ 12345678links: - app volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - &quot;8080&quot; 五、docker可视化工具 portainer启动 12345678docker run -d -p 8000:8000 -p 9000:9000 --name=protainer --restart=alw ays #只要停止就重启 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 1docker run -d -p 8000:8000 -p 9000:9000 --name=protainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v /usr/local/portainer_data:/data portainer/portainer","link":"/2021/07/28/docker-compose%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C/"},{"title":"dockerfile命令与操作","text":"dockerfile命令与操作 一、dockerfile 常用命令 1、FROM 指定父镜像 2、MAINTAINER 作者信息 3、RUN 执行命令 4、EXPOSE 暴露端口 5、WORKDIR 工作目录 6、COPY 复制文件 7、ADD 添加文件 8、VOLUME 定义外部可以挂载的数据卷 9、ENV 环境变量 10、ENTRYPOINT 入口 11、CMD 容器启动命令 二、dockerfile 不常用命令 1、LABEL 标签 2、RG 构建参数 3、USER 指定执行用户 4、HEALTHCHECK 健康检查 5、ONBUILD 触发器 6、STOPSIGNAL 发送信号量到宿主机 7、SHELL 指定执行脚本的shell 三、dockerfile构建命令 一、dockerfile 常用命令1、FROM 指定父镜像指定dockerfile基于那个image构建 1FROM centos:7 2、MAINTAINER 作者信息用来标明这个dockerfile谁写的 3、RUN 执行命令执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,“param2”] 1RUN yum install -y vim 4、EXPOSE 暴露端口定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 12格式: EXPOSE 8080 或者 EXPOSE 8080/udp 5、WORKDIR 工作目录指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 12WORKDIR /data WORKDIR bb 6、COPY 复制文件build的时候复制文件到image中 1COPY a.txt /data/bb 7、ADD 添加文件build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 12ADD a.txt /data/bbADD [远程下载链接] /data/bb 8、VOLUME 定义外部可以挂载的数据卷指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”] 1VOLUME /data/web 9、ENV 环境变量指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value 12ENV BASE_DIR /data/bb$BASE_DIR 10、ENTRYPOINT 入口一般在制作一些执行就关闭的容器中会使用 1ENTRYPOINT ls $BASE_DIR 11、CMD 容器启动命令提供启动容器时候的默认命令 和ENTRYPOINT配合使用，给ENTRYPOINT传参。 12格式 CMD command param1 param2 或者 CMD [&quot;command&quot; , &quot;param1&quot;,&quot;param2&quot;] 二、dockerfile 不常用命令1、LABEL 标签用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 2、RG 构建参数构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 3、USER 指定执行用户指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 4、HEALTHCHECK 健康检查指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 5、ONBUILD 触发器当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 6、STOPSIGNAL 发送信号量到宿主机该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。 7、SHELL 指定执行脚本的shell指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell 三、dockerfile构建命令1docker build -t mycentos7:01 . //当前目录 参考博客【1】docker安装部署neo4j 【2】Docker基础容器中bash: vi及ll: command not found问题解决 【3】docker 进入容器后,使用vim命令编辑文件报bash: ll: command not found","link":"/2021/07/18/dockerfile%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%93%8D%E4%BD%9C/"},{"title":"docker的基本使用","text":"待完善。。 docker的基本使用 1. docker 进程相关命令 2. docker 镜像相关命令 3. docker 容器相关命令 4. docker 配置数据卷命令 5. docker 容器与镜像相关操作 6. docker 启动后端口映射 1. docker 进程相关命令12345启动：systemctl start docker停止：systemctl stop docker重启：systemctl restart docker查看服务状态：systemctl status docker设置开机自启：systemctl enable docker 2. docker 镜像相关命令12345678910111213141)查看镜像: 查看本地所有的镜像 docker images / docker image ls -a docker images -q # 查看所用镜像的id 2) 搜索镜像:从网络中查找需要的镜像 docker search [image_name]3)拉取镜像: docker pull [image_name] (从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看。) 4) 删除一个或者多个镜像; docker rmi [image_name] docker rmi `docker images -q` # 删除所有本地镜像 3. docker 容器相关命令123456789101112131415161718192021222324252627281)查看容器 docker ps # 查看正在运行的容器 docker ps –a # 查看所有容器2)创建并启动容器 docker run -id --name=c1 -v /usr/local/dockersharefiles:/usr/local/dockersharefiles -p 18080:8080 -p 17474:7474 -p 17687:7687 -p 15432:5432 [image_name]:[version] /bin/bash========================================================共享目录：左边为宿主机的目录 右边为docker容器的目录端口映射：左边为宿主机的端口，右边为容器的端口参数说明：-i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器--name：为创建的容器命名。========================================================3)进入容器 docker exec 参数 # 退出容器，容器不会关闭4)停止容器 docker stop 容器名称5)启动容器 docker start 容器名称6)删除容器 docker rm 容器名称7)查看容器信息 docker inspect 容器名称8)查看容器日志 docker logs -f 容器名称或id 4. docker 配置数据卷命令123456789docker run ... -v 宿主机目录(文件):容器内目录(文件) ... 例如： docker run -it --name=c3 -v /root/data:/root/data_contain centos:7 /bin/bash ==================================================注意事项： 1. 目录必须是绝对路径 2. 如果目录不存在，会自动创建 3. 可以挂载多个数据卷 5. docker 容器与镜像相关操作1234567891)将容器转为镜像 docker commit 容器ID 镜像名称:版本号2)保存镜像文件 docker save -o [xxx.jar] [镜像名称]===========================================保存到了当前目录下 xxx.jar3)载入保存的镜像文件 docker load --input 文件 将制作好保存的镜像文件存储拷贝其他服务器可参考docker 拷贝镜像文件 6. docker 启动后端口映射123456781) 先停掉docker systemcel stop docker2) 在 /var/lib/docker/containers/[容器ID]/ 下找到hostconfig.json在端口进行添加就可以{&quot;8080/tcp&quot;:[[&quot;HostIp&quot;:&quot;&quot;,&quot;HostPort&quot;:&quot;18080&quot;]]}, 注意：要在PortBindings } 里面添加即可3、相同的目录下找到config.v2.json在ExposedPorts:下添加 &quot;8080/tcp&quot;: {} 注意：逗号啥的 按照原来的格式 填上去就可以 ，不然的话会出错。 容器转为的镜像 再根据镜像创建容器会不会 同时进行目录挂载","link":"/2021/07/14/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"docker的安装","text":"12345678910111、yum 包更新到最新 yum update2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm23、 设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo4、 安装docker，出现输入的界面都按 y yum install -y docker-ce5、 查看docker版本，验证是否验证成功 docker -v6、复制粘贴阿里云容器镜像服务","link":"/2021/07/14/docker%E7%9A%84%E5%AE%89%E8%A3%85/"},{"title":"docker网络配置命令","text":"1、查看网桥的配置 1docker network ls 2、创建自定义网桥 12docker create emsdocker create -d bridge ems 3、启动时指定网桥 1docker run -d -p 8080:8080 --network ems --name=mytomcat tomcat:8 4、删除网桥 1docker network rm aa 5 、查看网桥网络配置信息 1docker inspect dangdang","link":"/2021/07/31/docker%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4/"},{"title":"搭建个人博客思路总结","text":"整了大半天搞了搞博客，先写写大概思路，日后尽量完善和优化 博客的搭建步骤1、安装Node2、安装Hexo3、配置密钥4、发布博客5、增加暗黑模式6、调整侧边栏和文章的宽度7、调整侧边栏和文章的排版8、增加文章的目录9、优化底部9、增加评论区","link":"/2022/04/16/hello-world/"},{"title":"hlcx一面","text":"hlcy一面 1、项目 2、基础 3、多线程 4、数据库 5、JVM 6、分布式概念 参考博客 1、项目1）用户权限的模块有哪些？ 2）用户或角色有没有组的概念? 2、基础1） Object 有哪些方法？ 12345678910111213141516171819201.getClass方法获取运行时类型,返回值为Class对象2.hashCode方法返回该对象的哈希码值，是为了提高哈希表的性能（HashTable）3.equals方法判断两个对象是否相等，在Object源码中equals就是使用==去判断，所以在Object中equals是等价于==的，但是在String及某些类对equals进行了重写，实现不同的比较。4.clone方法主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里将参数改变，这时就需要在类中复写clone方法。如果在clone方法中调用super.clone()方法需要实现Cloneable接口,否则会抛出CloneNotSupportedException。此方法只实现了一个浅层拷贝,对于基本类型字段成功拷贝,但是如果是嵌套对象,只做了赋值,也就是只把地址拷贝了,所以没有成功拷贝,需要自己重写clone方法进行深度拷贝。5.toString方法返回一个String字符串,用于描述当前对象的信息,可以重写返回对自己有用的信息，默认返回的是当前对象的类名+hashCode的16进制数字。6.wait方法多线程时用到的方法，作用是让当前线程进入等待状态，同时也会让当前线程释放它所持有的锁。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，当前线程被唤醒7.notify方法多线程时用到的方法，唤醒该对象等待的某个线程8.notifyAll方法多线程时用到的方法，唤醒该对象等待的所有线程9.finalize对象在被GC释放之前一定会调用finalize方法，对象被释放前最后的挣扎,因为无法确定该方法什么时候被调用，很少使用。 2）重写equals方法为什么要重写hashcode? 1234提高比较的效率hashCode 相等的时候对象不一定相等，但是2个对象如果使用equals判断相等，那么他们的hashCode 一定相等。如果2个对象equals不相等但是hashCode相等 这个现象就是hash冲突，原因是hashCode是程序通过一系列算法计算出来的，所以存在重复的可能性。在hashCoe不可靠的情况下为什么还要使用它，因为hashCode比较的效率比equals要高，如果hashCode不一样那么equlas就没有必要调用了，可以提高性能 3）new 两个对象 调用equals方法 是true还是false？ 1重写equals方法且内容一样返回 true，否则返回false 4）new String aaa ，new String aaa一样还是不一样的？ 1是一样的。 String 重写了equals方法，比较每一个char 3、多线程1）创建线程池的方法？ 继承 Thread类，重写run方法 实现 Runnable 接口，重写run方法 实现 Callable接口，重写call方法。 2）创建线程池有哪些参数？ 123456核心线程数最大线程数空闲线程最大等待时间创建工厂类任务队列拒绝策略 3）在什么情况会出发拒绝策略？ 121、当我们调用 shutdown 等方法关闭线程池的时候，如果此时继续向线程池提交任务，就会被拒绝2、当任务队列（workQueue）已满，而且线程达到最大线程数（maximumPoolSize），如果再增加任务，也会被拒绝 4）空闲线程达到等待时间 是如何回收的如果让你设计 如何回收，如何回收多余时间 5）队列放的什么东西 6）非核心线程什么时候创建的 4、数据库1）Mysql事务，如何保证 12原子性、一致性、隔离性、持久性幻读、不可重复读 2）什么情况会产生死锁？ 123456789死锁就是说两个线程在争同一个资源，然后互不相让。1.事务一:两个操作update A;update B;事务二:两个操作update B;update A;线程一执行事务一到一半的时候，锁了A想要获得B的锁，与此同时事务二执行到了锁B，想要获得锁A的时候，因为互相都想要对方拥有的锁，而导致死锁！2.A线程先查询了一条记录(使用了共享锁)，与此同时B线程正要修改这条记录(使用了独占锁)，然后A线程突然想修改这条记录了，怎么办呢？升级锁。。而B线程想要降级为共享锁，必须要等到A线程释放掉共享锁，这样就形成了死锁！可以看到这个过程中是A占着共享锁想要升级，B占着独占锁想要降级，然后卡死！3.一个表结构，必须要有适当的索引等优化手段，如果在执行事务的时候，没有加索引条件甚至没有任何条件，那么将执行全表扫描，如果是多个事务在操作，很容易就发生了阻塞和死锁！所以字段加索引非常重要！！ 3）建立 a b c三个字段索引 sql语句where a =? b=? c=? 会不会走索引。 1会 4）a=? b&gt;? c = ? 怎么走索引 1范围查询忽略索引 5）建立索引还是慢了怎么办？ 1分库分表 5、JVMJvm 类加载 写程序依赖不同的jar包，这时候要依赖两个jar包 如何自定义类加载器 6、分布式概念什么是分布式、集群 参考博客答案综合自己思路及参考博客【1】java的Object类有哪些方法【2】mysql什么时候发生死锁_数据库什么时候会产生死锁？","link":"/2021/07/11/hlcx%E4%B8%80%E9%9D%A2/"},{"title":"idea常用配置及快捷键备忘录","text":"待完善 1Alt+7:查看当前类所有方法列表，快速定位方法","link":"/2021/08/06/idea%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"java socket 给你建议的小程序","text":"服务器端代码 123456789101112131415161718192021222324252627282930313233343536import java.io.IOException;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class severSocket { public static void main(String[] args) { // TODO Auto-generated method stub DailyAdviceServer server = new DailyAdviceServer(); server.go(); }}class DailyAdviceServer{ String[] adviceList = {&quot;早睡早起身体好&quot;,&quot;每天吃早餐&quot;,&quot;今天很美好&quot;,&quot;青春就是用来挥霍的&quot;}; public void go() { try { ServerSocket serverSock =new ServerSocket(5222);//监听客户端对该机器在端口5222的要求 while(true) { Socket sock = serverSock.accept();//该方法会等到接收到要求继续执行下面程序 PrintWriter writer =new PrintWriter(sock.getOutputStream());//建立输出链接 String advice=getAdvice(); //选择输出内容 writer.print(advice); writer.close();//输出后链接关闭 System.out.print(advice); } } catch (IOException e) { // TODO: handle exception e.printStackTrace(); } } public String getAdvice() { // TODO Auto-generated method stub int random = (int)(Math.random()*adviceList.length); return adviceList[random]; }} 客户端代码 123456789101112131415161718192021222324252627import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.Socket;public class chatSocket { public static void main(String[] args)throws Exception { // TODO Auto-generated method stub DailyClient client = new DailyClient(); client.go(); }}class DailyClient{ public void go() { try { Socket chatSk = new Socket(&quot;127.0.0.1&quot;,5222);//链接端口5222 InputStreamReader streamReader = new InputStreamReader(chatSk.getInputStream());//建立字节流 BufferedReader reader = new BufferedReader(streamReader);//建立缓冲区 String advice= reader.readLine(); System.out.println(&quot;Today you should: &quot;+advice); reader.close(); } catch (IOException e) { // TODO: handle exception e.printStackTrace(); } }}","link":"/2019/12/27/java%20socket%20%E7%BB%99%E4%BD%A0%E5%BB%BA%E8%AE%AE%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"java socket 聊天小程序","text":"服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package demo04;import java.awt.BorderLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.DataInputStream;import java.io.DataOutputStream;import java.net.ServerSocket;import java.net.Socket;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField;import javax.swing.ScrollPaneConstants;public class ownServer { public static void main(String[] args) { // TODO Auto-generated method stub new Server().launch(); }}class Server{ JFrame frame; JTextArea taArea; JTextField tfField; JButton sbButton; DataInputStream read ; DataOutputStream write; ServerSocket scServerSocket; Socket socket; public void launch() { CreateUI(); CreateNetWork(); new ServerWrite().start(); new ServerRead().start(); } public void CreateUI() { frame = new JFrame(&quot;MM Server&quot;); JPanel Panle = new JPanel(); taArea = new JTextArea(15,25); taArea.setLineWrap(true); taArea.setWrapStyleWord(true); taArea.setEditable(true); JScrollPane qScroller=newJScrollPane(taArea); qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS); qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS); tfField = new JTextField(20); sbButton = new JButton(&quot;发送&quot;); Panle.add(qScroller); Panle.add(tfField); Panle.add(sbButton); frame.getContentPane().add(BorderLayout.CENTER,Panle); frame.setSize(400,400); frame.setVisible(true); } public void close() { try { write.close(); read.close(); socket.close(); scServerSocket.close(); } catch (Exception e) { System.exit(-1); } } public void CreateNetWork() { try { scServerSocket =new ServerSocket(7780); socket= scServerSocket.accept(); read = new DataInputStream(socket.getInputStream()); write = new DataOutputStream(socket.getOutputStream()); System.out.print(&quot;网络连接&quot;); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } } class ServerRead extends Thread{ public void run() { while (true) { try { String message = read.readUTF(); taArea.append(&quot;对方：&quot;+message+ &quot;\\n&quot;); } catch (Exception e1) { // TODO: handle exception JOptionPane.showMessageDialog(taArea, &quot;提示: 服务端已经断开连接&quot;); //e.printStackTrace(); //System.exit(-1); return ; } } } }class ServerWrite extends Thread{ public void run() { tfField.addActionListener(new ServerListen()); sbButton.addActionListener(new ServerListen()); } } class ServerListen implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { try { String str = tfField.getText(); tfField.setText(&quot;&quot;); taArea.append(&quot;我: &quot; + str + &quot;\\n&quot;); write.writeUTF(str); } catch (Exception e2) { // TODO: handle exception e2.printStackTrace(); } } } } 客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package demo04;import java.awt.BorderLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.io.DataInputStream;import java.io.DataOutputStream;import java.net.Socket;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField;import javax.swing.ScrollPaneConstants;public class ownClient { public static void main(String[] args) { // TODO Auto-generated method stub new Client().launch(); }}class Client{ JTextArea taArea; JTextField tfField; JButton sbButton; DataInputStream read = null; DataOutputStream write = null; Socket socket; public void launch() { CreateUI(); CreatNetWork(); new ClientRead().start();; new ClientWrite().start();; } public void CreateUI() { JFrame frame = new JFrame(&quot;MM Client&quot;); JPanel Panle = new JPanel(); taArea = new JTextArea(15,25); taArea.setLineWrap(true); taArea.setWrapStyleWord(true); taArea.setEditable(true); JScrollPane qScroller = new JScrollPane(taArea); qScroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS); qScroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS); tfField = new JTextField(20); sbButton = new JButton(&quot;发送&quot;); Panle.add(qScroller); Panle.add(tfField); Panle.add(sbButton); frame.getContentPane().add(BorderLayout.CENTER,Panle); frame.setSize(400,400); frame.setVisible(true); } public void CreatNetWork() { // TODO Auto-generated method stub try { socket = new Socket(&quot;127.0.0.1&quot;,7780); write = new DataOutputStream(socket.getOutputStream()); read = new DataInputStream(socket.getInputStream()); System.out.print(&quot;已建立网络连接&quot;); } catch (Exception e) { // TODO: handle exception e.printStackTrace(); } } class ClientRead extends Thread{ public void run() { while (true) { try { String message= read.readUTF(); taArea.append(&quot;对方：&quot;+message+ &quot;\\n&quot;); } catch (Exception e1) { // TODO: handle exception JOptionPane.showMessageDialog(taArea, &quot;提示: 客户端已经断开连接&quot;); //e.printStackTrace(); //System.exit(-1); return ; } } } } class ClientWrite extends Thread{ public void run() { tfField.addActionListener(new ClientListen()); sbButton.addActionListener(new ClientListen()); } } class ClientListen implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { try { String str = tfField.getText(); tfField.setText(&quot;&quot;); taArea.append(&quot;我: &quot; + str + &quot;\\n&quot;); write.writeUTF(str); } catch (Exception e2) { // TODO: handle exception e2.printStackTrace(); } } } }","link":"/2019/12/29/java%20socket%20%E8%81%8A%E5%A4%A9%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"jdbc.properties 系统找不到指定路径问题","text":"今天学习jdbc 遇到jdbc.properties 系统找不到指定路径。在文件路径下确认了几遍都没有错。 最后发现问题所在，在我的项目文件 所在/E:/Program Files/IdeaProject/JDBC/out/production/Jdbc_day01/jdbc.properties 路径下 其中Program Files 中间 有空格 所以造成编码读取错误。 解决办法如下： 12345678ClassLoader cl = jdbcUtill.class.getClassLoader(); URL res = cl.getResource(&quot;jdbc.properties&quot;); URI uri = res.toURI(); 添加这行代码，并进行对应修改 String path = uri.getPath(); System.out.println(path); pro.load(new FileReader(path)); 修改好就可以了 具体问题分析请看下面这位答主的 【1】通过URL的getpath方法获取的返回路径因为中文或者空格等字符而乱码问题","link":"/2020/04/05/jdbc.properties%20%E7%B3%BB%E7%BB%9F%E6%89%BE%E4%B8%8D%E5%88%B0%E6%8C%87%E5%AE%9A%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"},{"title":"multiPartFile.transferTo(file) 第二次调用就报错FileNotFound-踩坑记录","text":"今天写代码遇到一个坑，第一次调用multiPartFile.transferTo(file) 正常运行，第二次就报错FileNotFound。并指向了C盘一个很深的目录。看了很多博客的解决办法都不管用，最后找到解决方案如下：不用multiPartFile.transferTo(file)该方法使用FileUtils.copyInputStreamToFile(multiPartFile.getInputStream(), file);将文件流复制到创建的file中需要导入包： 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; 后来发现又不行了，原来应该把获取输入流放到主线程中，通过线程池并发的获取输入流会造成冲突。参考【1】 解决办法参考的该博客：【1】：多线程使用MultipartFile上传excel文件报错【2】：SpringBoot MultiPartFile To File 问题 大概原因可参考【1】：MultipartFile.transferTo(dest) 报 FileNotFoundException","link":"/2021/08/09/multiPartFile.transferTo(file)%20%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8%E5%B0%B1%E6%8A%A5%E9%94%99FileNotFound-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"mybatis 返回插入数据的自增的id值","text":"在项目中有这样一个需求，插入一条数据返回其自增id可以如下修改xml sql语句 123&lt;insert id = &quot;insert&quot; parameterType = &quot;com.xx.xx.&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;insert into user(xxx,xxx) values(#{xxx}，#{xxx})&lt;/insert&gt; 主要是在标签中加入useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;","link":"/2021/06/21/mybatis%20%E8%BF%94%E5%9B%9E%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E8%87%AA%E5%A2%9E%E7%9A%84id%E5%80%BC/"},{"title":"mybatis执行查询语句查询不到结果，控制台输出sql语句复制到数据库中能查到数据","text":"java.util.Date 是 java.sql.Date","link":"/2021/02/05/mybatis%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%9F%A5%E8%AF%A2%E4%B8%8D%E5%88%B0%E7%BB%93%E6%9E%9C%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BAsql%E8%AF%AD%E5%8F%A5%E5%A4%8D%E5%88%B6%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%83%BD%E6%9F%A5%E5%88%B0%E6%95%B0%E6%8D%AE/"},{"title":"mysql转义 &#x2F; 搜索栏搜索_全部查出 bug","text":"项目中，搜索栏搜索 下划线 ,会全部查出来，这是由于mysql 中的下划线会转义。为了修复这个bug可以进行如下操作。在service层中，判断搜索的内容中是否包含下划线，如果包含将其进行替换为 “/_”。 1234if(content.contains(&quot;_&quot;)）{ String replaceContent = content.replace(&quot;_&quot;,&quot;/_&quot;);} 在sql语句中可以这样写 1select * from user where username like concat('%',#{content},'%') escape '/';","link":"/2021/06/21/mysql%E8%BD%AC%E4%B9%89%20!%20%E6%90%9C%E7%B4%A2%E6%A0%8F%E6%90%9C%E7%B4%A2_%E5%85%A8%E9%83%A8%E6%9F%A5%E5%87%BA%20bug/"},{"title":"postgresql 与 mysql 区别与联系","text":"postgresql 与 mysql 区别与联系 1、事务 2、索引 3、锁 4、mvcc 1、事务【psotgresql】读已提交（Read committed）是PostgreSQL中的默认隔离级别 PostgreSQL 9.1 之前只有两种隔离级别 读已提交和串行化，串行化相当于现在版本的不可重复读 在PostgreSQL中，你可以请求四种标准事务隔离级别中的任意一种，但是内部只实现了三种不同的隔离级别，即PostgreSQL 的读未提交模式的行为和读已提交相同。这是因为把标准隔离级别映射到PostgreSQL的多版本并发控制架构的唯一合理的方法。该表格也显示PostgreSQL 的可重复读实现不允许幻读 【mysql】可重复读（Repeatable read）是MySQL的默认事务隔离级别，其他大多数数据库为读已提交。 2、索引【psotgresql】PostgreSQL提供了多种索引类型：B-tree、Hash、GiST、SP-GiST、GIN和BRIN。每一种索引类型使用了一种不同的算法来适应不同类型的查询。默认情况下， CREATE INDEX命令创建适合于大部分情况的B-tree索引【mysql】B-tree、hash、R-tree full-textB树 哈希 R树 全文 3、锁【psotgresql】 死锁是指两个（或多个）事务相互持有对方想要的锁。例如，如果事务1在表A上获得一个排他锁，同时试图获取一个在表B上的排他锁，而事务2已经持有表B的排他锁，同时却正在请求表A上的一个排他锁，那么两个事务就都不能进行下去。PostgreSQL能够自动检测到死锁情况并且会通过中断其中一个事务从而允许其它事务完成来解决这个问题（具体哪个事务会被中断是很难预测的，而且也不应该依靠这样的预测）。 防止死锁的最好方法通常是保证所有使用一个数据库的应用都以一致的顺序在多个对象上获得锁。在上面的例子里，如果两个事务以同样的顺序更新那些行，那么就不会发生死锁。我们也应该保证一个事务中在一个对象上获得的第一个锁是该对象需要的最严格的锁模式。如果我们无法提前验证这些，那么可以通过重试因死锁而中断的事务来即时处理死锁。 【mysql】 4、mvccoid一行的对象标识符（对象ID）。该列只有在表使用WITH OIDS创建时或者default_with_oids配置变量被设置时才存在。该列的类型为oid（与列名一致），该类型详见第 8.18 节。tableoid包含这一行的表的OID。该列是特别为从继承层次（见第 5.9 节）中选择的查询而准备，因为如果没有它将很难知道一行来自于哪个表。tableoid可以与pg_class的oid列进行连接来获得表的名称。xmin插入该行版本的事务身份（事务ID）。一个行版本是一个行的一个特别版本，对一个逻辑行的每一次更新都将创建一个新的行版本。cmin插入事务中的命令标识符（从0开始）。xmax删除事务的身份（事务ID），对于未删除的行版本为0。对于一个可见的行版本，该列值也可能为非零。这通常表示删除事务还没有提交，或者一个删除尝试被回滚。cmax删除事务中的命令标识符，或者为0。ctid行版本在其表中的物理位置。注意尽管ctid可以被用来非常快速地定位行版本，但是一个行的ctid会在被更新或者被VACUUM FULL移动时改变。因此，ctid不能作为一个长期行标识符。OID或者最好是一个用户定义的序列号才应该被用来标识逻辑行。 扩招博客【1】mysql 及 posgresql之优劣势大比拼【2】PostgreSQL的元组、页面结构及索引查找原理【3】PostgreSQL并发处理方式——MVCC【4】PostgreSQL 的 MVCC 机制解析【5】正确的理解MySQL的MVCC及实现原理","link":"/2021/11/23/postgresql%20%E4%B8%8E%20mysql%20%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"},{"title":"sonarqube的基本使用","text":"参考博客【1】sonarqube使用手册","link":"/2021/07/23/sonarqube%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"title":"springboot修改配置yml文件","text":"123456789101112131415161718192021222324252627282930313233 @SuppressWarnings(&quot;all&quot;) public static void updateYamlFile() { String src = &quot;log-test/src/main/resources/application.yml&quot;; Yaml yaml = new Yaml(); FileWriter fileWriter = null; //层级map变量 Map&lt;String, Object&gt; springMap, dataSourceMap, resultMap; try { //读取yaml文件，默认返回根目录结构 resultMap = (Map&lt;String, Object&gt;) yaml.load(new FileInputStream(new File(src))); //get出spring节点数据 springMap = (Map&lt;String, Object&gt;) resultMap.get(&quot;spring&quot;); //get出数据库节点数据 dataSourceMap = (Map&lt;String, Object&gt;) springMap.get(&quot;datasource&quot;); //修改数据库url，我这个是封装的参数，你们测试可以写死一个值尝试修改即可// dataSourceMap.put(&quot;url&quot;, connect.getUrl());// //登录名// dataSourceMap.put(&quot;username&quot;, connect.getUsername()); //密码 dataSourceMap.put(&quot;password&quot;, &quot;root&quot;); //字符输出 fileWriter = new FileWriter(new File(src)); //用yaml方法把map结构格式化为yaml文件结构 fileWriter.write(yaml.dumpAsMap(resultMap)); //刷新 fileWriter.flush(); //关闭流 fileWriter.close(); } catch (Exception e) { e.printStackTrace(); throw new RuntimeException(&quot;对不起，yaml文件修改失败！&quot;); } }","link":"/2021/07/07/springboot%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AEyml%E6%96%87%E4%BB%B6/"},{"title":"springboot图片验证码开发","text":"待更新","link":"/2021/07/12/springboot%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%BC%80%E5%8F%91/"},{"title":"springboot日志配置","text":"待更新","link":"/2021/07/12/springboot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"},{"title":"springcloud基本使用总结","text":"springcloud基本使用总结 1、服务治理 1）Eureka 2）Consul 3）Naco 2、负载均衡 Ribbon 3、声明式服务调用 Feign 4、熔断器 Hystrix 5、网关 Gateway 6、分布式配置中心 Config 7、消息总线 Bus 8、消息驱动 Stream 9、链路追踪 Sleuth+Zipkin 1、服务治理1）Eureka2）Consul3）Naco2、负载均衡 Ribbon3、声明式服务调用 Feign4、熔断器 Hystrix5、网关 Gateway6、分布式配置中心 Config7、消息总线 Bus8、消息驱动 Stream9、链路追踪 Sleuth+Zipkin1）","link":"/2021/07/21/springcloud%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"title":"tomcat 服务器启动异常 报错","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215317-Apr-2020 22:28:09.183 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.catalina.core.ContainerBase.addChildInternal ContainerBase.addChild: start: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/test]] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:754) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734) at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1736) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:482) at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:431) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1468) at javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:76) at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1309) at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1401) at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:829) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:357) at sun.rmi.transport.Transport$1.run(Transport.java:200) at sun.rmi.transport.Transport$1.run(Transport.java:197) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.Transport.serviceCall(Transport.java:196) at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:573) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)Caused by: java.lang.IllegalArgumentException: Invalid &lt;url-pattern&gt; [failServlet] in servlet mapping at org.apache.catalina.core.StandardContext.addServletMappingDecoded(StandardContext.java:3197) at org.apache.catalina.core.StandardContext.addServletMappingDecoded(StandardContext.java:3184) at org.apache.catalina.startup.ContextConfig.configureContext(ContextConfig.java:1366) at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1180) at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:765) at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:299) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:94) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5154) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) ... 42 more17-Apr-2020 22:28:09.189 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.tomcat.util.modeler.BaseModelMBean.invoke Exception invoking method manageApp java.lang.IllegalStateException: ContainerBase.addChild: start: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/test]] at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:758) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734) at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1736) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:482) at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:431) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1468) at javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:76) at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1309) at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1401) at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:829) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[2020-04-17 10:28:09,214] Artifact web_anliproject:war exploded: Error during artifact deployment. See server log for details. at java.lang.reflect.Method.invoke(Method.java:498) at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:357) at sun.rmi.transport.Transport$1.run(Transport.java:200) at sun.rmi.transport.Transport$1.run(Transport.java:197) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.Transport.serviceCall(Transport.java:196) at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:573) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)17-Apr-2020 22:28:09.190 严重 [RMI TCP Connection(3)-127.0.0.1] org.apache.tomcat.util.modeler.BaseModelMBean.invoke Exception invoking method createStandardContext javax.management.RuntimeOperationsException: Exception invoking method manageApp at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:308) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:482) at org.apache.catalina.mbeans.MBeanFactory.createStandardContext(MBeanFactory.java:431) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:819) at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:801) at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1468) at javax.management.remote.rmi.RMIConnectionImpl.access$300(RMIConnectionImpl.java:76) at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1309) at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1401) at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:829) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:357) at sun.rmi.transport.Transport$1.run(Transport.java:200) at sun.rmi.transport.Transport$1.run(Transport.java:197) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.Transport.serviceCall(Transport.java:196) at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:573) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688) at java.security.AccessController.doPrivileged(Native Method) at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)Caused by: java.lang.IllegalStateException: ContainerBase.addChild: start: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/test]] at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:758) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:730) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734) at org.apache.catalina.startup.HostConfig.manageApp(HostConfig.java:1736) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.tomcat.util.modeler.BaseModelMBean.invoke(BaseModelMBean.java:300) ... 33 more17-Apr-2020 22:28:17.165 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [E:\\ProgramFileSoftware\\apache-tomcat-8.5.31-windows-64位\\apache-tomcat-8.5.31\\webapps\\manager]17-Apr-2020 22:28:17.413 信息 [localhost-startStop-1] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [E:\\ProgramFileSoftware\\apache-tomcat-8.5.31-windows-64位\\apache-tomcat-8.5.31\\webapps\\manager] has finished in [247] ms 今天在写登陆案例时候遇到 tomcat 服务器启动不了 启动报错 ，再查看上述报错内容后后发现这么一行问题： Caused by: java.lang.IllegalArgumentException: Invalid &lt;url-pattern&gt; [failServlet] in servlet mapping 由于[failServlet] 这个问题 后来看了一下写的分发的failServlet 结果 @WebServlet(“failServlet”) 忘记加‘/’了 改为 @WebServlet(“/failServlet”) 就好了","link":"/2020/04/17/tomcat%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E5%BC%82%E5%B8%B8%20%E6%8A%A5%E9%94%99/"},{"title":"一个事务与线程池线程的bug","text":"创建一个线程池核心线程为比如4，用改线程池执行restTemplate远程调用接口获取返回结果，并保存再数据库中。将7个任务提交。此时，通过调用另一个方法 ，修改数据库里未执行的任务的状态，从而取消任务。改取消任务方法添加了@Transcationl事务注解。 当执行取消任务时候，发现这种情况，提交的任务为7，线程池核心线程为4，这时候4个核心线程中有一个还没返回数据，就调用了下面的任务，下面没取消的任务，同样没返回结果。 参考博客【1】java实用型-高并发下RestTemplate的正确使用【2】httpclient 服务器响应时间,踩坑日记（九）：挖一个 RestTemplate 高并发的坑【3】ThreadPoolExecutor 线程池异常消失之刨根问底","link":"/2021/08/13/%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E7%9A%84bug/"},{"title":"修改neo4j端口及单独指定JDK","text":"修改neo4j端口 123456修改conf文件夹下neo4j.conf文件dbms.connector.bolt.listen_address=:7687dbms.connector.http.listen_address=:7474dbms.connector.https.listen_address=:7473 修改7487、7474、7473 这三个即可，同时在页面连接的 blot 处修改为 修改过的7687 的端口 指定JDK 1在启动程序 bin目录下 neo4j 在首行添加JAVA_HOME=/usr/local/jdk文件夹即可","link":"/2021/07/09/%E4%BF%AE%E6%94%B9neo4j%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%8D%95%E7%8B%AC%E6%8C%87%E5%AE%9AJDK/"},{"title":"修改tomcat端口","text":"修改conf文件夹下的server.xml文件 123451) &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt; 2) &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot;redirectPort=&quot;8443&quot; /&gt; 3) &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 分别修改8005、8080、8009即可， 其他的不用动","link":"/2021/07/09/%E4%BF%AE%E6%94%B9tomcat%E7%AB%AF%E5%8F%A3/"},{"title":"全局异常捕获处理方式总结","text":"1、定义异常的枚举类型 12345678910111213public enum AppExceptionEnum { ByZero(&quot;除以零异常&quot;); private String message; AppExceptionEnum( String message) { this.message = message; } public String getMessage() { return message; } public void setMessage(String message) { this.message = message; }} 2、自定义异常 12345678public class AppException extends RuntimeException{ public AppException(AppExceptionEnum appExceptionEnum) { super(appExceptionEnum.getMessage()); } public AppException(String message) { super(message); }} 3、定义返回结果集 1234567@Datapublic class ResultInfo { private boolean flag; private String msg; private Object data; private String code;} 4、定义全局异常捕获拦截 12345678910111213@RestControllerAdvice@Slf4jpublic class globalExceptionHandler { @ExceptionHandler(AppException.class) public ResultInfo appExceptionHandler(AppException appException){ ResultInfo resultInfo = new ResultInfo(); resultInfo.setFlag(false); resultInfo.setMsg(appException.getMessage()); resultInfo.setCode(&quot;500&quot;); log.info(appException.getMessage()); return resultInfo; }} 5、使用自定义异常 12345678910111213@Slf4j@RequestMapping(&quot;/test&quot;)@RestControllerpublic class TestController { @RequestMapping(&quot;/start&quot;) public void query(int b){ log.info(&quot;启动=======&quot;); if(b==0){ throw new AppException(&quot;程序错误hhh&quot;); } return; }}","link":"/2021/06/21/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"利用MockMvc进行单元测试时 不走拦截器（利用postman测试是走拦截器）","text":"遇到这个问题 主要是 在单元测试时候 要在MockMvc中配置拦截器才可以，要不然就是不走拦截器顺利 通过要走拦截器的话 在 测试类中 进行如下配置： 1234567891011增加如下代码：@MockBeanprivate MyInterceptor myInterceptor; //自己的拦截器对象@BeforeEachvoid setUp(){ mockMvc= MockMVCBuilders.standaloneSetup(xxxController) .addInterceptor(myInterceptor)//主要是这行代码 其他按需求变换 .build();}","link":"/2021/03/15/%E5%88%A9%E7%94%A8MockMvc%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%97%B6%20%E4%B8%8D%E8%B5%B0%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%88%E5%88%A9%E7%94%A8postman%E6%B5%8B%E8%AF%95%E6%98%AF%E8%B5%B0%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%89/"},{"title":"刷题-排序简单-API及套路总结","text":"刷题常用API及套路总结 1、常用API 2、排序-简单-约12题 1）1913. 两个数对之间的最大乘积差 2）1365. 有多少小于当前数字的数字（统计次数） 3）1859. 将句子排序 4）561. 数组拆分 I 5）1464. 数组中两元素的最大乘积 6）1051. 高度检查器 7）剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 8）242. 有效的字母异位词 9）888. 公平的糖果棒交换 10) 1608. 特殊数组的特征值 11）268. 丢失的数字 12）976. 三角形的最大周长 3、总结 n）模板 1、常用API1234567直接快排将数组排序： Arrays.sort(nums);切割字符串为数组 s.split(&quot; &quot;); 截取字符串 str[i].substring(0,9);比较两个数组是否一样 Arrays.equals(str1, str2);将字符串转为数组 char[] str1 = s.toCharArray(); 表示或去key为ch的value值 若没有则返回默认设置值0 table.getOrDefault(ch, 0)Arrays.stream(aliceSizes).sum(); 求和。 2、排序-简单-约12题1）1913. 两个数对之间的最大乘积差123456789101112【题目特点】：4 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt;= 10000【解题API要点】：for + if + else if + max1 2 + min1 2 + Integer.MIN_VALUE Integer.MAX_VALUE【原理】：利用for循环遍历nums数组，配合if 和 max min 进行判断： 把Integer最小值作为最大值，最大值作为最小值，凡是当前nums[i]大于max1(第一大)，就将当前nums[i]赋给max1，同时将max1(第一大)的值赋给max2(第二大) 如果nums[i]小于max1(第一大)，则看看它是否大于第二大的，如果大于则把当前nums[i]赋给max2。 同理min也一样。 遍历的结果就为找出了第一大、第二大、第一小以及第二小的值。【提升解析】：for if else if作为常见用法不是很稀奇， 但是配合空间的数值 max1 max2和min1 min2,通过来回倒腾 居然可以求出 最大两位 以及最小两位 而且时间复杂度为O(n)，空间复杂度为O(1).【拓展点】：求最大三位的数值以及最小三位的数值。【复杂度】：时间复杂度为O(n)，空间复杂度为O(1). 2）1365. 有多少小于当前数字的数字（统计次数）123456789【题目特点】：0 &lt;= nums[i] &lt;= 100 值域 给你数组的数值范围在0-100之间 共101个数。【解题API】： lamda表达式【原理】：1、遍历数组,将num[i]的值作为另一个数组的索引，由此遍历计算每个当前该数值作为索引位置的 出现次数。 2、通过遍历，前加后一个相邻的 计算小于等于该数的次数。 3、遍历数组长度，将改num[i]-1值作为cnt的索引的值 即小于当前值num[i]的次数，存放到 ret 新数组中【提升解析】：1、一个数组的值作为另一个数组的索引。可以计算相应位置的次数 2、for 循环遍历累加结合1可以计算出现的次数【拓展点】：无 功能性代码：将num[i]的值作为另一个数组cnt的索引 123for (int i = 0; i &lt; n; i++) { cnt[nums[i]]++;} 3）1859. 将句子排序12345678【题目特点】：s 中单词数目为 1 到 9 个。【解题API】： s.split(&quot; &quot;); str[i].substring(0,9);【原理】：1、通过API将字符串按照空格分割成数组 2、然后遍历数组同时截取每个字符串数字前的字符串，同时将字符串数字-‘0’转换为数字并作为索引放到数组中，将截取后的字符串赋值当前索引数组位置。 3、遍历复制后的顺序数组加上空格连成字符串。完美!【提升解析】:1、看到字符串应想起分割和截取字符串API的使用。2、要对数字敏感，尤其是是字符串中的数字，可以作为索引，进行排序。【拓展点】：无【复杂度】：时间O(n) 空间O(n) 4）561. 数组拆分 I1234567【题目特点】：【解题API】： 【原理】：1、直接排序变为由小到大 2、每组最左面的数为最小，直接遍历间隔2累加即可【提升解析】：排序分组后，每组左边为最小，遍历间隔。【拓展点】：遍历间隔【复杂度】：时间O(nlogn) 空间O(logn) 5）1464. 数组中两元素的最大乘积1234567【题目特点】：两个数乘积最大值【解题API】： 【原理】：解法一：直接排序，计算倒数两个数的乘积为最大。但时间复杂度为O(nlogn) 解法二：直接遍历，配合if else 以及两个max1 和max2 倒腾出最大的两个数，乘积为最大。时间复杂度O(n);【提升解析】：与1913. 两个数对之间的最大乘积差 很相似可进行对比。【拓展点】：【复杂度】：时间O(n)，空间O(1) 功能性代码：求出两个最大值 123456if (nums[i] &gt; n1) { n2 = n1; n1 = nums[i]; } else if (nums[i] &gt; n2) { n2 = nums[i]; } 6）1051. 高度检查器12345678【题目特点】：1 &lt;= heights[i] &lt;= 100 值域【1，100】 大于1的【解题API】： 【原理】：1、通过计次排序 也称桶排序，遍历所有 排好顺序 2、由于值域大于1，可以作为筛选条件，将桶中大于0的数值进行比较。 3、比较旧数组中的值与当前桶的索引即为排序后的相应值进行比较，若一样说明不用动，若不一样说明需要移动。统计次数【提升解析】：计次排序,与1365. 有多少小于当前数字的数字相似【拓展点】：【复杂度】：时间O(n) 空间O(1) 功能性代码：计次排序 1234int[] arr = new int[101]; for (int height : heights) { arr[height]++; } 7）剑指 Offer 21. 调整数组顺序使奇数位于偶数前面1234567891011【题目特点】：1 &lt;= nums[i] &lt;= 10000【解题API】： 【原理】：一般来说，第一直觉想到的就是遍历数组，制造两个数组分别存放再拼接，或是直接制造一个数组进行两次遍历把奇偶数分开。 此时复杂度都为O(n)。一般来说，第一时间想到的大多数情况下不能满足实际面试需求。 所以看是否可以在空间复杂度O(n)作文章，时间复杂度O(n)其实基本满足。 解法一：解析上来看，使用左右两个指针作为索引，分别从左右遍历奇数和偶数，并进行交换。当左右指重合跳出循环。 这一点和快速排序的一部分是一样的，通过左右指针来排序交换。只不过if条件不一样。这样可以减少空间上的存储，达到由O(n)-&gt;O(1)。 解法二：思路和解法一是一样的，也是通过两个指针进行交换，不过这个解法指针的顺序为同一侧，遇到奇数则开始交换。指针++。该种解法成为快慢指针法。【提升解析】：达到由O(n)-&gt;O(1)的效果，要想到通过左右指针/快慢指针来进行交换数组。【拓展点】：【复杂度】：时间O(n) 空间O(1) 8）242. 有效的字母异位词123456789101112131415【题目特点】：隐含条件 a-z 26 个字母【解题API】： Arrays.sort(str1); Arrays.equals(str1, str2); s.length() != t.length() ; char[] str1 = s.toCharArray(); s.charAt(i) - 'a'【原理】：方法一：首先判断一下两个字符串长度等否，不等则必然不同i，其次分别排序，并调用Arrays.equals(str1, str2);比较两个数组等否。 方法二：首先判断一下两个字符串长度等否，利用哈希表/计次排序/桶排序 分别统计两个字符串中，每个字符出现的次数，同时遍历第二个字符串进行--操作 同时判断当前字母 次数是否减为小于0，小于0则不一致。【提升解析】：排序：Arrays.equals(str1, str2);char[] str1 = s.toCharArray(); 桶排序：s.charAt(i) - 'a'【复杂度】： O(n) O(S)【拓展点】：如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ Map&lt;Character, Integer&gt; table = new HashMap&lt;Character, Integer&gt;(); table.put(ch, table.getOrDefault(ch, 0) + 1); 其中 table.getOrDefault(ch, 0),表示或去key为ch的value值 若没有则返回默认设置值0。 9）888. 公平的糖果棒交换1234567【题目特点】：该题的本质是交换两个数组的各一个数字，交换后使得两个数组中的数字的和相等。该题目描述有点拉垮，描述不清。sumA−x+y=sumB+x−y 该题就是解一个方程。 将交换数字后数组的和相等作为 等式。【解题API】： Arrays.stream(aliceSizes).sum(); 求和。【原理】：求俩个数组的值的总和，根据公式计算delta值，创建桶，并遍历添加爱丽丝的值进去，遍历鲍勃的数组通过公式计算出 爱丽丝满足结果的值，并去桶结构中找值，找到后付给创建的数组。【提升解析】：stream 流api【拓展点】：【复杂度】：时间O(n+m) 空间O(n) 10) 1608. 特殊数组的特征值12345678【题目特点】：【解题API】：【解题核心】：查看是否存在一个数值 t ，数组中的存在大于等于这个数值的个数刚好 == t ; 【原理】：看见个数 可以往 哈希表方向思考，当然排序的话也可以但是一般排序时间复杂度为O(nlogn),所以，优先考虑哈希表。 首先可以遍历数组找出最大值，其次创建一个桶存储数组中每个数字出现的次数，最后，从最大值开始遍历递减，同时累加数组中每个数字出现的次数，并判断当前累计次数是否和当前遍历的数字相等，此时 就是和【解题核心】中，从最大值遍历 看看 【数组中是否存在大于等于这个数值的】个数刚好 == 数组中的t ; 这一点转换要好好思考。如果存在return i; ,否则遍历结束return -1; 【提升解析】：存在【个数】，这种关键词，可以往计次排序方向思考。【拓展点】：查看是否存在一个数值 t ，数组中的存在【小于等于】这个数值的个数刚好 == t 【复杂度】： O(n),O(n) 11）268. 丢失的数字123456【题目特点】：【解题API】： 【原理】：通过题目线性时间复杂度来看，可以直接用计次排序来实现该题。但是这样时间空间复杂度都为O(n)。如果想要更近一步，一般是从空间复杂度上入手，减小空间复杂度，这种情况看看是否可以用数学或快慢指针的方法来解决。该题利用高斯求和公式减去数组的和，从而求得缺失的数字。【提升解析】：数学的方法【拓展点】：【复杂度】：时间O(n) 空间O(1) 12）976. 三角形的最大周长123456【题目特点】：【解题API】： 【原理】：排序，之后a&lt;=b&lt;=c,所以直接看是否 a+b&gt;=c 即可。【提升解析】：【拓展点】：【复杂度】：时间O(NlogN) 空间Ω(logN) ================================================ 3、总结12345678910111213141516171819202122232425262728293031323334计次排序： 2）1365. 有多少小于当前数字的数字（统计次数） 3）1859. 将句子排序 6）1051. 高度检查器 8）242. 有效的字母异位词 9）888. 公平的糖果棒交换 10) 1608. 特殊数组的特征值快速排序： 4）561. 数组拆分 I 12）976. 三角形的最大周长找最大最小： 1）1913. 两个数对之间的最大乘积差 5）1464. 数组中两元素的最大乘积两个指针： 7）剑指 Offer 21. 调整数组顺序使奇数位于偶数前面数学方法： 11）268. 丢失的数字小结： 通过对这12道题来看，排序-简单中用的最多的还是 计次排序 占50%，同时使用计次排序的 题也大概率可以用快排直接排序解题。根据时间复杂度以及解法频率可以确定从【 计次排序 &gt;= 找最大最小 &gt;= 两个指针 &gt;= 数学 】&gt; 快速排序 优先考虑前三种方向，最后没办法可以快排实现。 在使用计次排序时，要注意看一下，是否和桶中的次数有紧密关系，如果仅仅判断桶中是否包含某个元素，则可以直接用HashSet集合。计次排序：出现【有多少(个)...】【字符串中带数字】【排序/排列】【人数/个数/次数/总量/x个元素】【线性时间复杂度】找最大最小：出现【两元素..】的关系 如乘积、差等两个指针：出现 【调整顺序】 数学：在可以用计次排序后，可以看看题目中是否对于数字的逻辑公式有较强的相关性，可以尝试数学方法以减小空间复杂度。 ======================================================== n）模板123456【题目特点】：【解题API】： 【原理】：【提升解析】：【拓展点】：【复杂度】：时间O(n) 空间O(n)","link":"/2021/07/09/%E5%88%B7%E9%A2%98-%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95-API%E5%8F%8A%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/"},{"title":"刷题-排序简单-手撸总结","text":"刷题-排序简单-手撸总结 1) 剑指 Offer 40. 最小的k个数 - 重点 2)剑指 Offer 03. 数组中重复的数字 3 ) 169. 多数元素 4）面试题 01.01. 判定字符是否唯一 【位运算】 n) 模板 1) 剑指 Offer 40. 最小的k个数 - 重点12345【重点】【原理】：解法可以用哈希表来解决该题【注意点】：要注意重复的数字，所以 计次的桶中要减减，同时判断数组个数是否满足k。【提升解析】：【复杂度】：时间O(n) 空间O(n) 2)剑指 Offer 03. 数组中重复的数字1234567【题目特点】：题目要找任意一个重复的数字即可。【解题API】： 【原理】：直觉直接用哈希可以解决。但是一般用完哈希之后，再想想看看能不能减小空间复杂度。这个和数学方式不相关。但是题目，如果排好顺序的话每个索引都是与当前值相等的。不等的话，我也不知道，直接答案，交换两个数的位置，值作为索引。节省空间。【提升解析】：【拓展点】：【复杂度】：时间O(n) 空间O(1) 1234567891011哈希表方法要想起使用!set.add(num) 以及 Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); 操作 Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int repeat = -1; for (int num : nums) { if (!set.add(num)) { repeat = num; break; } } return repeat; 3 ) 169. 多数元素12345【题目特点】：次数【解题API】： 【原理】：该题的较好的解法，是保存当前值和次数置为1，并不断判断下一位与当前位是否相等，从而次数++ 或--，因为多数元素大于n/2,所以最终一定是 那个多数元素。【总结】：交换位置/次数++ -- 来减小空间复杂度。【复杂度】：时间O(n) 空间O(1) 4）面试题 01.01. 判定字符是否唯一 【位运算】n) 模板123456【题目特点】：【解题API】： 【原理】：【提升解析】：【拓展点】：【复杂度】：时间O(n) 空间O(n)","link":"/2021/07/18/%E5%88%B7%E9%A2%98-%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95-%E6%89%8B%E6%92%B8%E6%80%BB%E7%BB%93/"},{"title":"刷题-链表-API及套路总结","text":"刷题-链表-API及套路总结 一、链表-简单-API及套路总结 1、链表-简单-约7题 1）206.反转链表 2）21. 合并两个有序链表 3）141. 环形链表 4）剑指 Offer 22. 链表中倒数第k个节点 5）剑指 Offer 06. 从尾到头打印链表 6）234. 回文链表 2、刷题总结 二、链表-中等-API及套路总结 1、链表-中等-约12题 1） 2. 两数相加 2）19. 删除链表的倒数第 N 个结点 3）24. 两两交换链表中的节点 4）92. 反转链表 II 5）61. 旋转链表 6）142. 环形链表 II 7）82. 删除排序链表中的重复元素 II 8）146. LRU 缓存机制 9）148. 排序链表 10）86. 分隔链表 2、套路总结 模板 一、链表-简单-API及套路总结1、链表-简单-约7题1）206.反转链表123456789101112131415【题目特点】： 【原理】： 移动双指针/递归 迭代:使pre=null，cur=head，每次循环，申请临时节点存储当前节点的下一位，即，tmp=cur.next。然后将当前节点的下一位指向pre，即cur.next = pre，断开连接。当前节点赋值上一节点，即pre=cur。同时，临时节点赋值给当前节点，cur=tmp，这样两个指针完成一步移动。循环往返，当cur为null,此时pre指向尾部即头节点。 递归:先不断递归到尾部，然后返回尾结点。同时head.next.next = head,将尾部指向上一个节点，head.next = null,上一个节点的下一个置为null。最后每次返回尾结点，即头节点（倒转后）。【套路】： ListNode tmp = cur.next;cur.next = pre ;pre = cur ;cur = tmp;【复杂度】：时间复杂度为O(n)，空间复杂度为O(1). 1234ListNode tmp = cur.next;//申请临时存储节点cur.next = pre;//将下一位反向指向第一位pre = cur;//移动第一位，从而第三位指向第二位cur = tmp;//移动当前第二位往前移动一位,从而真实第二位反指向第一位实现反转 2）21. 合并两个有序链表123【题目特点】： 【原理】： 递归或双指针。与合并两个数组原理类似,类似双指针法,将较小的数值移动到临时存储空间内【复杂度】：时间复杂度为O(n+m)，空间复杂度为O(1). 写法套路 1234ListNode head = new ListNode(-1); 创建空头节点ListNode tmp = head;//将头节点赋予临时节点，同时临时节点作为移动指针不断移动。while(l1!=null&amp;&amp;l2!=null){}tmp.next=l1==null?l2:l1;// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可 3）141. 环形链表1234【题目特点】： 【原理】： 1、定义快慢指针，定理，若是环形链表，则快慢指针会相遇。 2、哈希表，遍历并添加到set集合中，若有重复则返回true,若最终为null,则不是环。【复杂度】：时间复杂度为O(n)，空间复杂度为O(1). 4）剑指 Offer 22. 链表中倒数第k个节点123456【题目特点】： 【原理】： 第一想法是先遍历整个链表求出长度，最后遍历n-k。不推荐 可以利用双指针的思想，1、先让快指针前进k步。 2、快慢指针同时前进n-k步(即快指针的移动到尾端，此时慢指针移动了n-k),此时慢指针所在位置为倒数第k个节点。【复杂度】：时间复杂度为O(n)，空间复杂度为O(1). 5）剑指 Offer 06. 从尾到头打印链表123【题目特点】： 【原理】： 利用栈的思想，遍历链表压栈，最后再弹栈，同时存储到数组中返回。【复杂度】：时间复杂度为O(n)，空间复杂度为O(1). 123456789101112Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); ListNode temp = head; while (temp != null) { stack.push(temp); temp = temp.next; } int size = stack.size(); int[] print = new int[size]; for (int i = 0; i &lt; size; i++) { print[i] = stack.pop().val; } return print; 6）234. 回文链表12345【题目特点】： 【原理】： 思路一：复制链表值到数组列表中，使用双指针法判断是否为回文。 思路二：递归 思路三：快慢指针。找到中间位置，偶数为右边位置，奇数为中间，然后传参将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后将链表再反转回来。【复杂度】：时间复杂度为O(n)，空间复杂度为O(1). 套路：快慢指针可以找到链表的中间。 1234567891011121314151617181920212223242526272829303132333435363738394041if (head == null) { return true; } // 找到前半部分链表的尾节点并反转后半部分链表 ListNode firstHalfEnd = endOfFirstHalf(head); ListNode secondHalfStart = reverseList(firstHalfEnd.next); // 判断是否回文 ListNode p1 = head; ListNode p2 = secondHalfStart; boolean result = true; while (result &amp;&amp; p2 != null) { if (p1.val != p2.val) { result = false; } p1 = p1.next; p2 = p2.next; } // 还原链表并返回结果 firstHalfEnd.next = reverseList(secondHalfStart); return result; } private ListNode endOfFirstHalf(ListNode head) { ListNode fast = head; ListNode slow = head; while (fast.next != null &amp;&amp; fast.next.next != null) { fast = fast.next.next; slow = slow.next; } return slow; } private ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; } 2、刷题总结1234567基本上最常用的为快慢指针即双指针来解题，其次为递归，但是一般递归可能现场有点反应不过来，所以可以先采用双指针来解题。若遇到【引用重复】的含义即相同的节点、交点可以采用哈希表set集合来解。从尾部遍历可想到栈的思想Stack.快慢指针：【中间】环形链表：可以理解成两个人速度一致， 走过的路程一致。那么肯定会同一个时间点到达终点。 二、链表-中等-API及套路总结1、链表-中等-约12题1） 2. 两数相加123456789101112【题目特点】： 移动指针+数学; 并进行相加，累计进位【复杂度】：O(max(m,n)) , O(1)【套路写法】：//创建虚拟头节点，并新建一个复制一份方便移动。 ListNode head = new ListNode(-1); ListNode cur = head;//三目运算 int n1 = l1!=null?l1.val:0;//余数与商 cur.next = new ListNode(sum % 10); carry = sum / 10;【总结】：掌握余数和除数，掌握三目运算。掌握创造虚拟。 2）19. 删除链表的倒数第 N 个结点12345678910【题目特点】：属于快慢指针【感想】：与简单题中返回倒数第n个节点类似，不过多了一步。【复杂度】：O(n),O(1)【套路写法】： ListNode dummy = new ListNode(0, head);和下面二者一个道理 ListNode dummyHead = new ListNode(0); dummyHead.next = head; 【总结】：掌握创造虚拟节点 掌握 [简单题中 返回倒数第n个节点]，即：快指针从n开始走，走N-n,从而慢指针走了N-n,就走到倒数n个节点。 掌握 删除下一个节点：second.next = second.next.next; 3）24. 两两交换链表中的节点123456789101112131415【题目特点】： 属于交换链表【解题方法】：递归或是迭代，迭代的大致思路是创建三个节点,一个主节点，两个临时节点，通过来回交换，从而移动两个节点的位置。注意是位置而不是节点的值 【复杂度】：O(n),O(1)【套路写法】： //创建虚拟节点，或是头节点，令其下一位指向头节点，这样做的好处是移动的时候可以，刚好移动目标点位之前，从而方便做一些操作。最后结束返回dummyHead.next;完美 ListNode dummyHead = new ListNode(0); dummyHead.next = head; return dummyHead.next;// 交换两个节点的位置的套路 temp.next = node2; node1.next = node2.next; node2.next = node1; tmp = node1;【总结】：掌握创造虚拟节点。 掌握交换两个节点的写法。 4）92. 反转链表 II1234567【总结】：该题与简单题类似，是简单题的升级版，简单题的反转是将整个链表反转，而该题是将中间一部分进行反转。 但是该题是头插，移动并往头部插入节点，和简单题稍微有点不太一样。next = cur.next;cur.next = next.next;next.next = pre.next;pre.next = next; 5）61. 旋转链表12345【题目特点】：移动链表,和两数相加都用到取余操作【原理】：【套路写法】： int add = n - k % n;//计算移动k个元素，移动前面的个数，计算从哪个断开 6）142. 环形链表 II7）82. 删除排序链表中的重复元素 II123【题目特点】：【原理】：核心点是创造哑节点，并比较下一个和下下个，一样的话赋值给x,并循环比较同时删除【套路写法】： 8）146. LRU 缓存机制9）148. 排序链表10）86. 分隔链表123【题目特点】：【原理】：核心点是创造小链表和大链表，将小于该数存到小链表里，将大于等于改数存到大链表里。最后将大链表置空，将小链表的next指向大链表头部。【套路写法】： 2、套路总结12感觉中等题目，比简单题目，多了一步操作。原理还是简单题的组合。很多题都创造哑节点，比较下一位和下下位 模板12345678【题目特点】：【解题API】：【解题核心】： 【原理】：【提升解析】： 【拓展点】： 【复杂度】：【套路写法】：","link":"/2021/07/24/%E5%88%B7%E9%A2%98-%E9%93%BE%E8%A1%A8-API%E5%8F%8A%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/"},{"title":"刷题常用API及套路总结","text":"刷题常用API及套路总结 1、排序 1.1 排序API 1.2 排序套路总结 2、线性表 1.1 线性表API 1.2 线性表套路总结 1、排序1.1 排序API123456781) Arrays.sort(nums); 直接快排将数组排序：2) s.split(&quot; &quot;); 切割字符串为数组 3) str[i].substring(0,9); 截取字符串 4) Arrays.equals(str1, str2);比较两个数组是否一样5) char[] str1 = s.toCharArray(); 将字符串转为数组6) table.getOrDefault(ch, 0) 表示或去key为ch的value值 若没有则返回默认设置值0 7) Arrays.stream(aliceSizes).sum(); 求和。 1.2 排序套路总结12345678910 排序-简单中用的最多的还是 计次排序 占50%，同时使用计次排序的 题也大概率可以用快排直接排序解题。 根据时间复杂度以及解法频率可以确定从【 计次排序 &gt;= 找最大最小 &gt;= 两个指针 &gt;= 数学 】&gt; 快速排序 优先考虑前三种方向，最后没办法可以快排实现。 在使用计次排序时，要注意看一下，是否和桶中的次数有紧密关系，如果仅仅判断桶中是否包含某个元素，则可以直接用HashSet集合。 [计次排序]：出现【有多少(个)...】【字符串中带数字】【排序/排列】【人数/个数/次数/总量/x个元素】【线性时间复杂度】 [找最大最小]：出现【两元素..】的关系 如乘积、差等 [两个指针]：出现 【调整顺序】 [数学]：在可以用计次排序后，可以看看题目中是否对于数字的逻辑公式有较强的相关性，可以尝试数学方法以减小空间复杂度。 2、线性表1.1 线性表API1.2 线性表套路总结","link":"/2021/07/18/%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8API%E5%8F%8A%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/"},{"title":"复习-Servlet","text":"1、为什么要用Servlet 因为web服务器(tomcat、Weblogic、iis、apache)没有处理动态资源请求的能力(即该请求需要计算),只能处理静态资源的请求，如果要让web服务器处理动态资源的请求，则需要使用CGI1程序、组件加容器的方式。 为了可以让服务器可以处理动态资源等，如展示相应的用户名。Servlet应运而生。 2、什么是Servlet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 将来我们自定义一个类，实现Servlet接口，复写方法。 3、Servlet执行原理与过程 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的标签体内容。 如果有，则在找到对应的全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 4、Servlet的生命周期123456789101112131415161718*1. 被创建：执行init方法，只执行一次* * Servlet什么时候被创建？ 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。 * 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 * &lt;load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值*2. 提供服务：执行service方法，执行多次* * 每次访问Servlet时，Service方法都会被调用一次。*3. 被销毁：执行destroy方法，只执行一次* * Servlet被销毁时执行。服务器关闭时，Servlet被销毁 * 只有服务器正常关闭时，才会执行destroy方法。 * destroy方法在Servlet被销毁之前执行，一般用于释放资源 5、Servlet的体系结构12345678910111213 Servlet -- 接口 |GenericServlet -- 抽象类 |HttpServlet -- 抽象类 GenericServlet：将Servlet接口中其他的方法做了默认空实现， 只将service()方法作为抽象，将来定义Servlet类时，可以继承 GenericServlet，实现service()方法即可 HttpServlet：对http协议的一种封装，简化操作1. 定义类继承HttpServlet2. 复写doGet/doPost方法","link":"/2021/01/28/%E5%A4%8D%E4%B9%A0-Servlet/"},{"title":"复习-会话技术之Cookie 与 Session","text":"会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie： 概念：客户端会话技术，将数据保存到客户端 实现原理： 基于响应头set-cookie和请求头cookie实现 . cookie的细节1. 一次可不可以发送多个cookie?* 可以* 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 2. cookie在浏览器中保存多长时间？1. 默认情况下，当浏览器关闭后，Cookie数据被销毁2. 持久化存储：* setMaxAge(int seconds)1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效2. 负数：默认值3. 零：删除cookie信息 3. cookie能不能存中文？* 在tomcat 8 之前 cookie中不能直接存储中文数据。* 需要将中文数据转码—一般采用URL编码(%E3)* 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4. cookie共享问题？1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？* 默认情况下cookie不能共享* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录* 如果要共享，则可以将path设置为”/“2. 不同的tomcat服务器间cookie共享问题？* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享* setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 5. Cookie的特点和作用1. cookie存储数据在客户端浏览器2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)* 作用：1. cookie一般用于存出少量的不太敏感的数据2. 在不登录的情况下，完成服务器对客户端的身份识别 Session： 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 原理： Session的实现是依赖于Cookie的。 细节：1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？* 默认情况下。不是。* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。Cookie c = new Cookie(“JSESSIONID”,session.getId());c.setMaxAge(60*60);response.addCookie©; **2\\. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？** \\* 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 \\* session的钝化： \\* 在服务器正常关闭之前，将session对象系列化到硬盘上 \\* session的活化： \\* 在服务器启动后，将session文件转化为内存中的session对象即可。 **3\\. session什么时候被销毁？** 1\\. 服务器关闭 2\\. session对象调用invalidate\\(\\) 。 3\\. session默认失效时间 30分钟 选择性配置修改 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全","link":"/2021/01/30/%E5%A4%8D%E4%B9%A0-%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%E4%B9%8BCookie%20%E4%B8%8E%20Session/"},{"title":"复习-转发与重定向","text":"请求转发：一种在服务器内部的资源跳转方式 步骤：1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 特点：1. 浏览器地址栏路径不发生变化2. 只能转发到当前服务器内部资源中。3. 转发是一次请求 重定向：资源跳转的方式 重定向的特点:redirect1. 地址栏发生变化2. 重定向可以访问其他站点(服务器)的资源3. 重定向是两次请求。不能使用request对象来共享数据","link":"/2021/01/30/%E5%A4%8D%E4%B9%A0-%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/"},{"title":"多线程总结","text":"多线程总结 1、创建线程的四种方式 2、线程池 2.1 线程池的7个参数？ 2.2 线程池的提交两种方式的区别？ 1、创建线程的四种方式12345678910111、通过继承Thread类实现，复写run方法 特点：继承Tread类，实例化一个线程时，调用start()也只能启动一个线程。实例化多个线程实例，每个实例调用start()可以启动多个线程，但线程中的资源也是多份的。2、实现Runnable接口，复写run方法 特点：实现Runnable接口只需要实例化一个线程类就可以创建多个线程，并且多个线程共享同一份资源 继承了Tread类后不能同时继承其它类了，而实现了Runnable接口后还可实现其它接口和继承其它类。 Thread本身也是Runnable接口的一个实现类。3、实现Callable call方法中可以有返回值，并且抛出异常。Runnable的run方法无返回值。4、创建线程池实现 就是创建一个实现多个线程的容器 线程池提供了一个线程队列，队列中保存所有等待状态的线程，避免创建与销毁额外开销，提高了响应速度。 2、线程池2.1 线程池的7个参数？1234567corePoolSize 核心线程池基本大小，核心线程数maximumPoolSize 线程池最大线程大小keepAliveTime 线程空闲后的存活时间TimeUnit unit 线程空闲后的存活时间单位BlockingQueue workQueue 存放任务的阻塞队列ThreadFactory threadFactory 创建线程的工厂//该接口的目的是定制一个线程，可以设置线程的优先级、名字、是否后台线程、状态等。RejectedExecutionHandler handler 当阻塞队列和最大线程池都满了之后的饱和策略 2.2 线程池的提交两种方式的区别？123456execute()和submit()第一种区别：1、execute只能提交Runnable类型的任务，无返回值。2、submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务，会有一个类型为Future的返回值，但当任务类型为Runnable时，返回值为null。第二种区别：execute在执行任务时，如果遇到异常会直接抛出，而submit不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常","link":"/2021/07/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"},{"title":"学习-JVM","text":"1、JVM内存模型 2、双亲委派机制 3、pc寄存器的优点 4、pc寄存器为什么设为私有？","link":"/2021/02/24/%E5%AD%A6%E4%B9%A0-JVM/"},{"title":"学习-MySQL索引","text":"1、什么是索引 2、索引的分类有哪些 3、聚簇索引和非聚簇索引 4、B树和B+树 5、MyISAM 和 InnoDb的区别？ 6、数据库事务ACID？解释一致性 7、数据库的四个隔离级别？脏读和幻读？怎么解决幻读？MVCC了解吗？ 8、Left join, inner join, right join的区别","link":"/2021/02/16/%E5%AD%A6%E4%B9%A0-MySQL%E7%B4%A2%E5%BC%95/"},{"title":"安装完宝塔后 数据库 ROOT账号无法登陆解决办法","text":"最近部署阿里云环境配置 发现通过宝塔面板安装mysql 数据库 之后 用navicat 远程连接 登录root 登录不了。密码是宝塔用户的密码。 后来通过查找很多办法终于解决了。 解决办法如下 两行代码okMySQL 8 开启root 用户远程访问 12345mysql&gt; create user 'root'@'%' identified by '12345678';Query OK, 0 rows affected (0.02 sec) mysql&gt; grant all on *.* to 'root'@'%';Query OK, 0 rows affected (0.02 sec)","link":"/2021/05/06/%E5%AE%89%E8%A3%85%E5%AE%8C%E5%AE%9D%E5%A1%94%E5%90%8E%20%E6%95%B0%E6%8D%AE%E5%BA%93%20ROOT%E8%B4%A6%E5%8F%B7%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"将Json格式的字符串转为Json格式对象提取其中的Value值","text":"项目中遇到 要将返回的字符串（Json格式）再转为Json格式提取其中的 键值对 ，以下总结了两种办法。 1234567891011第一种思路是 转成 JSONObject的对象 String jsonStr = &quot;假设是Json格式的字符串&quot;;JSONObject jsonobject = JSONObject.parseObject(jsonStr );String s = jsonobject.getSttring(&quot;要提取的Json格式的字符串中的key值&quot;);//如果是 Json格式的字符串里面键下还包含着键值对则用以下的方法String jsonStr = &quot;假设是Json格式的字符串&quot;;JSONObject jsonobject = JSONObject.parseObject(jsonStr );JSONObject key = jsonobject.getJSONObject(&quot;key&quot;);String s = key.getSttring(&quot;要提取的Json格式的字符串中的key值&quot;); 12345第二种思路是转成Map 或 List集合String jsonStr = &quot;假设是Json格式的字符串&quot;;Map map =(Map) JSONUtil.parse(jsonStr);Object key = map.get(&quot;key&quot;); 12345678910第三种[{&quot;model&quot;:[&quot;123&quot;,&quot;456&quot;,&quot;789&quot;]}] @RequestMapping(&quot;/send1&quot;) public ResuktInfo task1(){ String s = &quot;[{\\&quot;model\\&quot;:[\\&quot;123\\&quot;,\\&quot;456\\&quot;,\\&quot;789\\&quot;]}]&quot;; String strip = StringUtils.strip(s, &quot;[]&quot;); JSONObject jo = JSONObject.parseObject(new String(strip)); Object modelV = jo.get(&quot;model&quot;); return ResuktInfo.succ(&quot;success&quot;,modelV); } 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.51&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt;&lt;/dependency&gt; 参考博客【1】java字符串转json【2】com.alibaba.fastjson.JSONArray cannot be cast to com.alibaba.fastjson.JSONObject","link":"/2021/03/15/%E5%B0%86Json%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BAJson%E6%A0%BC%E5%BC%8F%E5%AF%B9%E8%B1%A1%E6%8F%90%E5%8F%96%E5%85%B6%E4%B8%AD%E7%9A%84Value%E5%80%BC/"},{"title":"工作实际开发中用到的工厂模式形式","text":"工作实际开发中用到的工厂模式形式 1、定义配置文件 2、改进工厂类 3、通过工厂调用 1、定义配置文件12american=com.itheima.pattern.factory.config_factory.AmericanCoffeelatte=com.itheima.pattern.factory.config_factory.LatteCoffee 2、改进工厂类12345678910111213141516171819202122232425public class CoffeeFactory { private static Map&lt;String,Coffee&gt; map = new HashMap(); static { Properties p = new Properties(); InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;); try { p.load(is); //遍历Properties集合对象 Set&lt;Object&gt; keys = p.keySet(); for (Object key : keys) { //根据键获取值（全类名） String className = p.getProperty((String) key); //获取字节码对象 Class clazz = Class.forName(className); Coffee obj = (Coffee) clazz.newInstance(); map.put((String)key,obj); } } catch (Exception e) { e.printStackTrace(); } } public static Coffee createCoffee(String name) { return map.get(name); }} 3、通过工厂调用","link":"/2021/08/04/%E5%B7%A5%E4%BD%9C%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BD%A2%E5%BC%8F/"},{"title":"抽象类与final总结","text":"抽象类与final总结 一、抽象类 1、为什么要用抽象类 2、抽象类的基本原则 二、final 1、为什么要用final 2、final的基本原则 一、抽象类1、为什么要用抽象类 当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了。在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。 2、抽象类的基本原则1）抽象类和抽象方法必须使用 abstract 关键字修饰2）抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类3）抽象类不能实例化4）抽象类可以有构造方法5）抽象类的子类：要么重写抽象类中的所有抽象方法，要么是抽象类。 二、final1、为什么要用final final代表最终的意思，可以修饰成员方法，成员变量，类。不希望成员方法，成员变量，类，会被改变，所以要用到final。 2、final的基本原则 fianl修饰类：该类不能被继承（不能有子类，但是可以有父类） final修饰方法：该方法不能被重写 final修饰变量：表明该变量是一个常量，不能再次赋值 变量是基本类型,不能改变的是值 变量是引用类型,不能改变的是地址值,但地址里面的内容是可以改变的 12345public static void main(String[] args){ final Student s = new Student(23); s = new Student(24); // 错误 s.setAge(24); // 正确}","link":"/2021/08/12/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8Efinal%E6%80%BB%E7%BB%93/"},{"title":"数据结构-排序","text":"** 基础排序**1、冒泡排序 2、选择排序 12每次选择最小值的索引,与首位进行交换时间复杂度：O(n2) 12345678910111213141516171819202122public class Selection { public static void sort(Comparable[] a) { for (int i = 0; i &lt; a.length - 1; i++) { int minIndex = i; for (int j = i + 1; j &lt; a.length; j++) { if (greater(a[minIndex], a[j])) { minIndex = j; } } exch(a, i, minIndex); } } private static boolean greater(Comparable v, Comparable w) { return v.compareTo(w) &gt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; }} 3、插入排序 123451.把所有的元素分为两组，已经排序的和未排序的；2.找到未排序的组中的第一个元素，向已经排序的组中进行插入；3.倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；时间复杂度：O(n2) 12345678910111213141516171819202122public class Insertion { public static void sort(Comparable[] a) { for (int i = 1; i &lt; a.length; i++) { for (int j = i; j &gt; 0; j--) { if (greater(a[j - 1], a[j])) { exch(a, j - 1, j); } else { break; } } } } public static boolean greater(Comparable v, Comparable w) { return v.compareTo(w) &gt; 0; } public static void exch(Comparable[] a, int i, int j) { Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; }} ** 高级排序**4、希尔排序 12分组插入排序O(n^(1.3—2)) 12345678910111213141516171819202122232425262728293031public class Shell { public static void sort(Comparable[] a) { int N = a.length; int h =1; while (h&lt;N/2){ h=2*h+1; } while (h&gt;=1){ for (int i = h; i &lt; N; i++) { for (int j = i; j &gt;=h; j-=h) { if (greater(a[j - h], a[j])) { exch(a, j - h, j); } else { break; } } } h/=2; } } public static boolean greater(Comparable v, Comparable w) { return v.compareTo(w) &gt; 0; } public static void exch(Comparable[] a, int i, int j) { Comparable temp; temp = a[i]; a[i] = a[j]; a[j] = temp; }} 5、归并排序 1O(NlogN) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Merge { private static Comparable[] assist;//归并所需要的辅助数组 public static void sort(Comparable[] a) { assist = new Comparable[a.length]; int lo = 0; int hi = a.length-1; sort(a, lo, hi); } private static void sort(Comparable[] a, int lo, int hi) { if (hi &lt;= lo) { return; } int mid = lo + (hi - lo) / 2; sort(a, lo, mid); sort(a, mid + 1, hi); merge(a, lo, mid, hi); } private static void merge(Comparable[] a, int lo, int mid, int hi) { int i = lo; int p1 = lo; int p2 = mid + 1; while (p1 &lt;= mid &amp;&amp; p2 &lt;= hi) { if(less(a[p1],a[p2])){ assist[i++]=a[p1++]; }else { assist[i++]=a[p2++]; } } while (p1&lt;=mid){ assist[i++]=a[p1++]; } while (p2&lt;=hi){ assist[i++]=a[p2++]; } for (int index=lo;index&lt;=hi;index++){ a[index]=assist[index]; } } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; }} 6、快速排序 1O(NlogN) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Quick { public static void sort(Comparable[] a) { int lo = 0; int hi = a.length-1; sort(a, lo, hi); } private static void sort(Comparable[] a, int lo, int hi) { if (hi &lt;= lo) { return; } int partition = partition(a, lo, hi); sort(a,lo,partition-1); sort(a,partition+1,hi); } private static int partition(Comparable[] a, int lo, int hi) { Comparable key = a[lo]; int left = lo; int right = hi+1; while (true){ while (less(key,a[--right])){ if(right==lo){ break; } } while (less(a[++left],key)){ if(left==hi){ break; } } if(left&gt;=right){ break; }else { exch(a,left,right); } } exch(a,lo,right); return right;//right就是切分的界限 } private static boolean less(Comparable v, Comparable w) { return v.compareTo(w) &lt; 0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; }} 稳定性： 12稳定：冒泡排序 插入排序 归并排序不稳定：选择排序 希尔排序 快速排序","link":"/2021/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"},{"title":"数据结构之符号表","text":"符号表的基本结构 基本结构 有序符号表 基本结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class OrderSymbolTable&lt;Key extends Comparable&lt;Key&gt;,Value&gt; { //记录首结点 private Node head; //记录符号表中元素的个数 private int N; private class Node{ //键 public Key key; //值 public Value value; //下一个结点 public Node next; public Node(Key key, Value value, Node next) { this.key = key; this.value = value; this.next = next; } } public OrderSymbolTable() { this.head = new Node(null,null,null); this.N=0; } //获取符号表中键值对的个数 public int size(){ return N; } //往符号表中插入键值对 public void put(Key key,Value value){ //符号表中已经存在了键为key的键值对，那么只需要找到该结点，替换值为value即可 Node n = head; while(n.next!=null){ //变换n n = n.next; //判断n结点存储的键是否为key，如果是，则替换n结点的值 if (n.key.equals(key)){ n.value = value; return; } } //如果符号表中不存在键为key的键值对，只需要创建新的结点，保存要插入的键值对，把新结点插入到链表的头部 head.next=新结点即可 Node newNode = new Node(key, value, null); Node oldFirst = head.next; newNode.next = oldFirst; head.next = newNode; //元素个数+1； N++; } //删除符号表中键为key的键值对 public void delete(Key key){ //找到键为key的结点，把该结点从链表中删除 Node n = head; while(n.next!=null){ //判断n结点的下一个结点的键是否为key，如果是，就删除该结点 if (n.next.key.equals(key)){ n.next = n.next.next; N--; return; } //变换n n = n.next; } } //从符号表中获取key对应的值 public Value get(Key key){ //找到键为key的结点 Node n = head; while(n.next!=null){ //变换n n = n.next; if (n.key.equals(key)){ return n.value; } } return null; }} 有序符号表12345678910111213141516171819202122//往符号表中插入键值对 public void put(Key key,Value value){ //定义两个Node变量，分别记录当前结点和当前结点的上一个结点 Node curr = head.next; Node pre = head; while(curr!=null &amp;&amp; key.compareTo(curr.key)&gt;0){ //变换当前结点和前一个结点即可 pre = curr; curr = curr.next; } //如果当前结点curr的键和要插入的key一样，则替换 if (curr!=null &amp;&amp; key.compareTo(curr.key)==0){ curr.value = value; return; } //如果当前结点curr的键和要插入的key不一样，把新的结点插入到curr之前 Node newNode = new Node(key, value, curr); pre.next = newNode; //元素的个数+1； N++; }","link":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AC%A6%E5%8F%B7%E8%A1%A8/"},{"title":"栈","text":"栈之链栈 1、栈的基本结构 2、括号匹配问题 3、逆波兰表达式问题 1、栈的基本结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Iterator;public class Stack&lt;T&gt; implements Iterable&lt;T&gt;{ //记录首结点 private Node head; //栈中元素的个数 private int N; private class Node{ public T item; public Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } public Stack() { this.head = new Node(null,null); this.N=0; } //判断当前栈中元素个数是否为0 public boolean isEmpty(){ return N==0; } //获取栈中元素的个数 public int size(){ return N; } //把t元素压入栈 public void push(T t){ //找到首结点指向的第一个结点 Node oldFirst = head.next; //创建新结点 Node newNode = new Node(t, null); //让首结点指向新结点 head.next = newNode; //让新结点指向原来的第一个结点 newNode.next=oldFirst; //元素个数+1； N++; } //弹出栈顶元素 public T pop(){ //找到首结点指向的第一个结点 Node oldFirst = head.next; if (oldFirst==null){ return null; } //让首结点指向原来第一个结点的下一个结点 head.next=oldFirst.next; //元素个数-1； N--; return oldFirst.item; } @Override public Iterator&lt;T&gt; iterator() { return new SIterator(); } private class SIterator implements Iterator{ private Node n; public SIterator(){ this.n=head; } @Override public boolean hasNext() { return n.next!=null; } @Override public Object next() { n = n.next; return n.item; } }} 2、括号匹配问题1234567891011121314151617181920212223242526272829/** * 判断str中的括号是否匹配 * @param str 括号组成的字符串 * @return 如果匹配，返回true，如果不匹配，返回false */public static boolean isMatch(String str){ //1.创建栈对象，用来存储左括号 Stack&lt;String&gt; chars = new Stack&lt;&gt;(); //2.从左往右遍历字符串 for (int i = 0; i &lt; str.length(); i++) { String currChar = str.charAt(i)+ &quot;&quot;; //3.判断当前字符是否为左括号，如果是，则把字符放入到栈中 if (currChar.equals(&quot;(&quot;)){ chars.push(currChar); }else if(currChar.equals(&quot;)&quot;)){ //4.继续判断当前字符是否是有括号，如果是，则从栈中弹出一个左括号，并判断弹出的结果是否为null,如果为null证明没有匹配的左括号，如果不为null，则证明有匹配的左括号 String pop = chars.pop(); if (pop==null){ return false; } } } //5.判断栈中还有没有剩余的左括号，如果有，则证明括号不匹配 if (chars.size()==0){ return true; }else{ return false; }} 3、逆波兰表达式问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static int caculate(String[] notaion) { //1.定义一个栈，用来存储操作数 Stack&lt;Integer&gt; oprands = new Stack&lt;&gt;(); //2.从左往右遍历逆波兰表达式，得到每一个元素 for (int i = 0; i &lt; notaion.length; i++) { String curr = notaion[i]; //3.判断当前元素是运算符还是操作数 Integer o1; Integer o2; Integer result; switch (curr) { case &quot;+&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 + o1; oprands.push(result); break; case &quot;-&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 - o1; oprands.push(result); break; case &quot;*&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 * o1; oprands.push(result); break; case &quot;/&quot;: //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中 o1 = oprands.pop(); o2 = oprands.pop(); result = o2 / o1; oprands.push(result); break; default: //5.操作数，把该操作数放入到栈中； oprands.push(Integer.parseInt(curr)); break; } } //6.得到栈中最后一个元素，就是逆波兰表达式的结果 int result = oprands.pop(); return result; }","link":"/2021/01/27/%E6%A0%88/"},{"title":"查看postgresql索引","text":"1、查看postgresql索引使用（复制粘贴即可） 123456select relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch from pg_stat_user_indexes order by idx_scan asc, idx_tup_read asc, idx_tup_fetch asc; 2、查看postgresql 单个表的索引使用（复制粘贴即可） 12345678select relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch from pg_stat_user_indexes where relname = '表名' order by idx_scan asc, idx_tup_read asc, idx_tup_fetch asc;","link":"/2021/07/07/%E6%9F%A5%E7%9C%8Bpostgresql%E7%B4%A2%E5%BC%95/"},{"title":"栈与队列的应用","text":"2.3.1 栈在括号匹配中的应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stddef.h&gt;#define true 1;#define false 0;#define MaxSize 50typedef struct { char data[MaxSize]; int top;} SqStack;// 1、初始化栈// 2、判空操作// 3、进栈// 4、出栈// 5、读取栈顶元素// 6、销毁栈// 1、初始化栈void InitStack(SqStack *S){ S-&gt;top=-1;}// 2、判空操作int StackEmpty(SqStack *S){ if(S-&gt;top==-1) {return true; } else {return false;}}// 3、进栈int Push (SqStack *S,char x){ if(S-&gt;top==MaxSize-1) return false; S-&gt;data[++S-&gt;top]=x; return true;}// 4、出栈int Pop (SqStack *S,char *x){ if(S-&gt;top==-1) return false; *x=S-&gt;data[S-&gt;top--]; return true;}// 5、读取栈顶元素int GetTop(SqStack *S,char x){ if(S-&gt;top==-1) return false; x=S-&gt;data[S-&gt;top--]; return true;} // 6、销毁栈int Destroy(SqStack *S){ // for (int i = 0; i &lt; S-&gt;top; i++) // { // S-&gt;data[S-&gt;top++]=0; // } S-&gt;top=-1; return 1;}//栈括号的应用int bracketCheck(char str[],int len){ SqStack S; InitStack(&amp;S); for (int i = 0; i &lt; len; i++) { if (str[i]=='('||str[i]=='['||str[i]=='{') { Push(&amp;S, str[i]); }else { if (StackEmpty(&amp;S)) { return false; } char *topElem; Pop(&amp;S,topElem); if(str[i]==')' &amp;&amp; *topElem!='(') return false; if(str[i]==']' &amp;&amp; *topElem!='[') return false; if(str[i]=='}' &amp;&amp; *topElem!='{') return false; } } return StackEmpty(&amp;S);}int main(){ char str1[] = &quot;{({{[]})}&quot;; if (bracketCheck(str1, 10)) { printf(&quot;match success!&quot;); } else { printf(&quot;match fail!&quot;); } return 0;} 2.3.2 栈在表达式求值中的应用2.3.3 栈在递归中的应用2.3.4 队列在层次遍历中的应用","link":"/2021/01/31/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/"},{"title":"树","text":"树 1、基本结构 2、基础遍历 1）前序遍历 2）中序遍历 3）后序遍历 3、层序遍历 4、应用问题 1）二叉树的最大深度问题 2）折纸问题 1、基本结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public class BinaryTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt; { //记录根结点 private Node root; //记录树中元素的个数 private int N; private class Node { //存储键 public Key key; //存储值 private Value value; //记录左子结点 public Node left; //记录右子结点 public Node right; public Node(Key key, Value value, Node left, Node right) { this.key = key; this.value = value; this.left = left; this.right = right; } } //获取树中元素的个数 public int size() { return N; } //向树中添加元素key-value public void put(Key key, Value value) { root = put(root, key, value); } //向指定的树x中添加key-value,并返回添加元素后新的树 private Node put(Node x, Key key, Value value) { //如果x子树为空， if (x==null){ N++; return new Node(key,value, null,null); } //如果x子树不为空 //比较x结点的键和key的大小： int cmp = key.compareTo(x.key); if (cmp&gt;0){ //如果key大于x结点的键，则继续找x结点的右子树 x.right = put(x.right,key,value); }else if(cmp&lt;0){ //如果key小于x结点的键，则继续找x结点的左子树 x.left = put(x.left,key,value); }else{ //如果key等于x结点的键，则替换x结点的值为value即可 x.value = value; } return x; } //查询树中指定key对应的value public Value get(Key key) { return get(root,key); } //从指定的树x中，查找key对应的值 public Value get(Node x, Key key) { //x树为null if (x==null){ return null; } //x树不为null //比较key和x结点的键的大小 int cmp = key.compareTo(x.key); if (cmp&gt;0){ //如果key大于x结点的键，则继续找x结点的右子树 return get(x.right,key); }else if(cmp&lt;0){ //如果key小于x结点的键，则继续找x结点的左子树 return get(x.left,key); }else{ //如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可 return x.value; } } //删除树中key对应的value public void delete(Key key) { delete(root, key); } //删除指定树x中的key对应的value，并返回删除后的新树 public Node delete(Node x, Key key) { //x树为null if (x==null){ return null; } //x树不为null int cmp = key.compareTo(x.key); if (cmp&gt;0){ //如果key大于x结点的键，则继续找x结点的右子树 x.right = delete(x.right,key); }else if(cmp&lt;0){ //如果key小于x结点的键，则继续找x结点的左子树 x.left = delete(x.left,key); }else{ //如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x； //让元素个数-1 N--; //得找到右子树中最小的结点 if (x.right==null){ return x.left; } if (x.left==null){ return x.right; } Node minNode = x.right; while(minNode.left!=null){ minNode = minNode.left; } //删除右子树中最小的结点 Node n = x.right; while(n.left!=null){ if (n.left.left==null){ n.left=null; }else{ //变换n结点即可 n = n.left; } } //让x结点的左子树成为minNode的左子树 minNode.left = x.left; //让x结点的右子树成为minNode的右子树 minNode.right = x.right; //让x结点的父结点指向minNode x = minNode; } return x; } //查找整个树中最小的键 public Key min(){ return min(root).key; } //在指定树x中找出最小键所在的结点 private Node min(Node x){ //需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点 if (x.left!=null){ return min(x.left); }else{ return x; } } //在整个树中找到最大的键 public Key max(){ return max(root).key; } //在指定的树x中，找到最大的键所在的结点 public Node max(Node x){ //判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点 if (x.right!=null){ return max(x.right); }else{ return x; } }} 2、基础遍历1）前序遍历1234567891011121314151617181920212223//获取整个树中所有的键 public Queue&lt;Key&gt; preErgodic(){ Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); preErgodic(root, keys); return keys; } //获取指定树x的所有键，并放到keys队列中 private void preErgodic(Node x,Queue&lt;Key&gt; keys){ if (x==null){ return; } //把x结点的key放入到keys中 keys.enqueue(x.key); //递归遍历x结点的左子树 if (x.left!=null){ preErgodic(x.left,keys); } //递归遍历x结点的右子树 if (x.right!=null){ preErgodic(x.right,keys); } } 2）中序遍历12345678910111213141516171819202122232425//使用中序遍历获取树中所有的键 public Queue&lt;Key&gt; midErgodic(){ Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); midErgodic(root,keys); return keys; } //使用中序遍历，获取指定树x中所有的键，并存放到key中 private void midErgodic(Node x,Queue&lt;Key&gt; keys){ if (x==null){ return; } //先递归，把左子树中的键放到keys中 if (x.left!=null){ midErgodic(x.left,keys); } //把当前结点x的键放到keys中 keys.enqueue(x.key); //在递归，把右子树中的键放到keys中 if(x.right!=null){ midErgodic(x.right,keys); } } 3）后序遍历12345678910111213141516171819202122//使用后序遍历，把整个树中所有的键返回public Queue&lt;Key&gt; afterErgodic(){ Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); afterErgodic(root,keys); return keys;}//使用后序遍历，把指定树x中所有的键放入到keys中private void afterErgodic(Node x,Queue&lt;Key&gt; keys){ if (x==null){ return ; } //通过递归把左子树中所有的键放入到keys中 if (x.left!=null){ afterErgodic(x.left,keys); } //通过递归把右子树中所有的键放入到keys中 if (x.right!=null){ afterErgodic(x.right,keys); } //把x结点的键放入到keys中 keys.enqueue(x.key);} 3、层序遍历123456789101112131415161718192021222324//使用层序遍历，获取整个树中所有的键 public Queue&lt;Key&gt; layerErgodic(){ //定义两个队列，分别存储树中的键和树中的结点 Queue&lt;Key&gt; keys = new Queue&lt;&gt;(); Queue&lt;Node&gt; nodes = new Queue&lt;&gt;(); //默认，往队列中放入根结点 nodes.enqueue(root); while(!nodes.isEmpty()){ //从队列中弹出一个结点，把key放入到keys中 Node n = nodes.dequeue(); keys.enqueue(n.key); //判断当前结点还有没有左子结点，如果有，则放入到nodes中 if (n.left!=null){ nodes.enqueue(n.left); } //判断当前结点还有没有右子结点，如果有，则放入到nodes中 if (n.right!=null){ nodes.enqueue(n.right); } } return keys; } 4、应用问题1）二叉树的最大深度问题123456789101112131415161718192021222324252627282930//获取整个树的最大深度public int maxDepth(){ return maxDepth(root);}//获取指定树x的最大深度private int maxDepth(Node x){ if (x==null){ return 0; } //x的最大深度 int max=0; //左子树的最大深度 int maxL=0; //右子树的最大深度 int maxR=0; //计算x结点左子树的最大深度 if (x.left!=null){ maxL = maxDepth(x.left); } //计算x结点右子树的最大深度 if (x.right!=null){ maxR = maxDepth(x.right); } //比较左子树最大深度和右子树最大深度，取较大值+1即可 max = maxL&gt;maxR?maxL+1:maxR+1; return max;} 2）折纸问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//通过模拟对折N次纸，产生树 public static Node&lt;String&gt; createTree(int N){ //定义根结点 Node&lt;String&gt; root=null; for (int i = 0; i &lt; N; i++) { //1.当前是第一次对折 if (i==0){ root = new Node&lt;&gt;(&quot;down&quot;,null,null); continue; } //2.当前不是第一次对折 //定义一个辅助队列，通过层序遍历的思想，找到叶子结点，叶子结点添加子节点 Queue&lt;Node&gt; queue = new Queue&lt;&gt;(); queue.enqueue(root); //循环遍历队列 while(!queue.isEmpty()){ //从队列中弹出一个结点 Node&lt;String&gt; tmp = queue.dequeue(); //如果有左子结点，则把左子结点放入到队列中 if (tmp.left!=null){ queue.enqueue(tmp.left); } //如果有右子结点，则把右子结点放入到队列中 if (tmp.right!=null){ queue.enqueue(tmp.right); } //如果同时没有左子结点和右子结点，那么证明该节点是叶子结点，只需要给该节点添加左子结点和右子结点即可 if (tmp.left==null &amp;&amp; tmp.right==null){ tmp.left = new Node&lt;String&gt;(&quot;down&quot;, null,null); tmp.right = new Node&lt;String&gt;(&quot;up&quot;,null,null); } } } return root; } //打印树中每个结点到控制台 public static void printTree(Node&lt;String&gt; root){ //需要使用中序遍历完成 if (root==null){ return; } //打印左子树的每个结点 if (root.left!=null){ printTree(root.left); } //打印当前结点 System.out.print(root.item+&quot; &quot;); //打印右子树的每个结点 if (root.right!=null){ printTree(root.right); } } //结点类 private static class Node&lt;T&gt;{ public T item;//存储元素 public Node left; public Node right; public Node(T item, Node left, Node right) { this.item = item; this.left = left; this.right = right; } }","link":"/2021/08/16/%E6%A0%91/"},{"title":"浅谈 什么是封装、继承与多态？","text":"初学面向对象编程会遇到封装、继承与多态这三个核心概念，下面来说一下个人对于这三个概念的理解。 1、什么是封装，为什么要用到封装？ 抛开抽象概念来讲，封装就是将一些复杂的或是不想让你看到的事物包装起来，叫做封装。从程序的角度来说就是，把一些内部复杂的逻辑或是不想让其他人员修改程序内部进而把部分程序包装起来，叫做封装。举一个 遥控器的例子，无论是电动玩具赛车遥控器还是电视遥控器，其内部都是复杂的电路板，由于技术人员出于对电路板的保护的角度来说或是不想其他人员看到内部丑陋的电路板的角度来说，通过手柄来包装都能达到这俩种效果。 2、什么是继承？为什么要用到继承？ 继承，顾名思义，就是继承某个东西或者财产。比如，子代继承父代的财产，一个人继承他爸爸财产房产一类的东西，但是有些东西是不能继承的，比如这个人他爸爸年轻时学到的知识、经历，他不能继承（程序中的私有字段等）。从程序的角度来说，就是子类继承父类的一下字段属性方法等。那为什么要用到继承的？ 一切工具以及方法都是为了解决问题而发明创造的。继承也不例外。起初还没有面向对象思想的语言产生时，利用古老的语言或者C语言编程时，当发现一块需求的功能与之前一块已经写过代码实现的功能类似，这怎么办？一般都是粘贴代码，但是慢慢的人们发现，这种办法当代码数量很多时候极有可能少粘贴或是粘贴多了引发不必要的错误。由此，人们想了一种方法叫做继承。 3、什么是多态？为什么要用到多态？ 多态，即多种状态。首先说一下为什么要使用多态，是为了解决代码的灵活性这个问题，为了写出通用的代码使得程序更加好维护便捷。譬如，我有好多台打印机，有各种型号的，可以打印黑白的、彩色的和更多彩色的。我想只通过一个按钮（方法）就让这各种型号的打印同时打印。不需要再去每个打印机按一下各自的按钮，若是这样不得累死我，假设有几百台打印机的话。所以这时候就需要多态，通过将子类引用赋给父类对象，通过循环列表 就可以用同一种方法去调用不同的打印机，多方便！","link":"/2020/01/09/%E6%B5%85%E8%B0%88%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%EF%BC%9F/"},{"title":"线性表-链表","text":"线性表之链表 一、Java 1、单向链表 2、双向链表 3、链表反转 4、快慢指针 4.1 中间值问题 4.2 单向链表是否有环问题 4.3 有环链表入口问题 5、循环链表 6、约瑟夫问题 一、Java1、单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import java.util.Iterator;public class LinkList&lt;T&gt; implements Iterable&lt;T&gt;{ //记录头结点 private Node head; //记录链表的长度 private int N; //结点类 private class Node { //存储数据 T item; //下一个结点 Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } public LinkList() { //初始化头结点、 this.head = new Node(null,null); //初始化元素个数 this.N=0; } //清空链表 public void clear() { head.next=null; this.N=0; } //获取链表的长度 public int length() { return N; } //判断链表是否为空 public boolean isEmpty() { return N==0; } //获取指定位置i出的元素 public T get(int i) { //通过循环,从头结点开始往后找，依次找i次，就可以找到对应的元素 Node n = head.next; for(int index=0;index&lt;i;index++){ n=n.next; } return n.item; } //向链表中添加元素t public void insert(T t) { //找到当前最后一个结点 Node n = head; while(n.next!=null){ n=n.next; } //创建新结点，保存元素t Node newNode = new Node(t, null); //让当前最后一个结点指向新结点 n.next=newNode; //元素的个数+1 N++; } //向指定位置i出，添加元素t public void insert(int i, T t) { //找到i位置前一个结点 Node pre = head; for(int index=0;index&lt;=i-1;index++){ pre=pre.next; } //找到i位置的结点 Node curr = pre.next; //创建新结点，并且新结点需要指向原来i位置的结点 Node newNode = new Node(t, curr); //原来i位置的前一个节点指向新结点即可 pre.next=newNode; //元素的个数+1 N++; } //删除指定位置i处的元素，并返回被删除的元素 public T remove(int i) { //找到i位置的前一个节点 Node pre = head; for(int index=0;index&lt;=i-1;i++){ pre=pre.next; } //要找到i位置的结点 Node curr = pre.next; //找到i位置的下一个结点 Node nextNode = curr.next; //前一个结点指向下一个结点 pre.next=nextNode; //元素个数-1 N--; return curr.item; } //查找元素t在链表中第一次出现的位置 public int indexOf(T t) { //从头结点开始，依次找到每一个结点，取出item，和t比较，如果相同，就找到了 Node n = head; for(int i=0;n.next!=null;i++){ n=n.next; if (n.item.equals(t)){ return i; } } return -1; } @Override public Iterator&lt;T&gt; iterator() { return new LIterator(); } private class LIterator implements Iterator{ private Node n; public LIterator(){ this.n=head; } @Override public boolean hasNext() { return n.next!=null; } @Override public Object next() { n = n.next; return n.item; } }} 2、双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160import java.util.Iterator;public class TowWayLinkList&lt;T&gt; implements Iterable&lt;T&gt; { //首结点 private Node head; //最后一个结点 private Node last; //链表的长度 private int N; //结点类 private class Node{ public Node(T item, Node pre, Node next) { this.item = item; this.pre = pre; this.next = next; } //存储数据 public T item; //指向上一个结点 public Node pre; //指向下一个结点 public Node next; } public TowWayLinkList() { //初始化头结点和尾结点 this.head = new Node(null,null,null); this.last=null; //初始化元素个数 this.N=0; } //清空链表 public void clear(){ this.head.next=null; this.head.pre=null; this.head.item=null; this.last=null; this.N=0; } //获取链表长度 public int length(){ return N; } //判断链表是否为空 public boolean isEmpty(){ return N==0; } //获取第一个元素 public T getFirst(){ if (isEmpty()){ return null; } return head.next.item; } //获取最后一个元素 public T getLast(){ if (isEmpty()){ return null; } return last.item; } //插入元素t public void insert(T t){ if (isEmpty()){ //如果链表为空： //创建新的结点 Node newNode = new Node(t,head, null); //让新结点称为尾结点 last=newNode; //让头结点指向尾结点 head.next=last; }else { //如果链表不为空 Node oldLast = last; //创建新的结点 Node newNode = new Node(t, oldLast, null); //让当前的尾结点指向新结点 oldLast.next=newNode; //让新结点称为尾结点 last = newNode; } //元素个数+1 N++; } //向指定位置i处插入元素t public void insert(int i,T t){ //找到i位置的前一个结点 Node pre = head; for(int index=0;index&lt;i;index++){ pre=pre.next; } //找到i位置的结点 Node curr = pre.next; //创建新结点 Node newNode = new Node(t, pre, curr); //让i位置的前一个结点的下一个结点变为新结点 pre.next=newNode; //让i位置的前一个结点变为新结点 curr.pre=newNode; //元素个数+1 N++; } //获取指定位置i处的元素 public T get(int i){ Node n = head.next; for(int index=0;index&lt;i;index++){ n=n.next; } return n.item; } //找到元素t在链表中第一次出现的位置 public int indexOf(T t){ Node n = head; for(int i=0;n.next!=null;i++){ n=n.next; if (n.next.equals(t)){ return i; } } return -1; } //删除位置i处的元素，并返回该元素 public T remove(int i){ //找到i位置的前一个结点 Node pre = head; for(int index=0;index&lt;i;index++){ pre=pre.next; } //找到i位置的结点 Node curr = pre.next; //找到i位置的下一个结点 Node nextNode= curr.next; //让i位置的前一个结点的下一个结点变为i位置的下一个结点 pre.next=nextNode; //让i位置的下一个结点的上一个结点变为i位置的前一个结点 nextNode.pre=pre; //元素的个数-1 N--; return curr.item; } @Override public Iterator&lt;T&gt; iterator() { return new TIterator(); } private class TIterator implements Iterator{ private Node n; public TIterator(){ this.n=head; } @Override public boolean hasNext() { return n.next!=null; } @Override public Object next() { n=n.next; return n.item; } }} 3、链表反转12345678910111213141516171819202122 //用来反转整个链表 public void reverse(){ //判断当前链表是否为空链表，如果是空链表，则结束运行，如果不是，则调用重载的reverse方法完成反转 if (isEmpty()){ return; } reverse(head.next); }//反转指定的结点curr，并把反转后的结点返回 public Node reverse(Node curr){ if (curr.next==null){ head.next=curr; return curr; } //递归的反转当前结点curr的下一个结点；返回值就是链表反转后，当前结点的上一个结点 Node pre = reverse(curr.next); //让返回的结点的下一个结点变为当前结点curr； pre.next=curr; //把当前结点的下一个结点变为null curr.next=null; return curr; } 4、快慢指针4.1 中间值问题12345678910111213/*** @param first 链表的首结点* @return 链表的中间结点的值*/public static String getMid(Node&lt;String&gt; first) {Node&lt;String&gt; slow = first;Node&lt;String&gt; fast = first;while(fast!=null &amp;&amp; fast.next!=null){ fast=fast.next.next; slow=slow.next;} return slow.item;} 4.2 单向链表是否有环问题1234567891011121314151617/*** 判断链表中是否有环* @param first 链表首结点* @return ture为有环，false为无环*/public static boolean isCircle(Node&lt;String&gt; first) {Node&lt;String&gt; slow = first;Node&lt;String&gt; fast = first;while(fast!=null &amp;&amp; fast.next!=null){fast = fast.next.next;slow = slow.next;if (fast.equals(slow)){ return true; }} return false;} 4.3 有环链表入口问题12345678910111213141516171819202122232425 /*** 查找有环链表中环的入口结点* @param first 链表首结点* @return 环的入口结点*/public static Node getEntrance(Node&lt;String&gt; first) {Node&lt;String&gt; slow = first;Node&lt;String&gt; fast = first;Node&lt;String&gt; temp = null;while(fast!=null &amp;&amp; fast.next!=null){ fast = fast.next.next; slow=slow.next;if (fast.equals(slow)){ temp = first; continue;}if (temp!=null){ temp=temp.next;if (temp.equals(slow)){ return temp; } }} return null;} 5、循环链表1234567891011121314151617//构建结点 Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(1, null); Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(2, null); Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(3, null); Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(4, null); Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(5, null); Node&lt;Integer&gt; six = new Node&lt;Integer&gt;(6, null); Node&lt;Integer&gt; seven = new Node&lt;Integer&gt;(7, null);//构建单链表 first.next = second; second.next = third; third.next = fourth; fourth.next = fifth; fifth.next = six; six.next = seven;//构建循环链表,让最后一个结点指向第一个结点 seven.next = first; 6、约瑟夫问题123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test { public static void main(String[] args) throws Exception { //1.构建循环链表 Node&lt;Integer&gt; first = null; //记录前一个结点 Node&lt;Integer&gt; pre = null; for (int i = 1; i &lt;= 41; i++) {//第一个元素 if (i == 1) { first = new Node(i, null); pre = first; continue; } Node&lt;Integer&gt; node = new Node&lt;&gt;(i, null); pre.next = node; pre = node; if (i == 41) {//构建循环链表，让最后一个结点指向第一个结点 pre.next = first; } }//2.使用count，记录当前的报数值 int count = 0;//3.遍历链表，每循环一次，count++ Node&lt;Integer&gt; n = first; Node&lt;Integer&gt; before = null; while (n != n.next) {//4.判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0； count++; if (count == 3) {//删除当前结点 before.next = n.next; System.out.print(n.item + &quot;,&quot;); count = 0; n = n.next; } else { before = n; n = n.next; } } /*打印剩余的最后那个人*/ System.out.println(n.item); }}","link":"/2021/01/25/%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8/"},{"title":"线性表-顺序表","text":"线性表之顺序表 一、Java 一、Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import java.util.Iterator;public class SequenceList&lt;T&gt; implements Iterable&lt;T&gt;{ //存储元素的数组 private T[] eles; //记录当前顺序表中的元素个数 private int N; //构造方法 public SequenceList(int capacity){ //初始化数组 this.eles=(T[])new Object[capacity]; //初始化长度 this.N=0; } //将一个线性表置为空表 public void clear(){ this.N=0; } //判断当前线性表是否为空表 public boolean isEmpty(){ return N==0; } //获取线性表的长度 public int length(){ return N; } //获取指定位置的元素 public T get(int i){ return eles[i]; } //向线型表中添加元素t public void insert(T t){ if (N==eles.length){ resize(2*eles.length); } eles[N++]=t; } //在i元素处插入元素t public void insert(int i,T t){ if (N==eles.length){ resize(2*eles.length); } //先把i索引处的元素及其后面的元素依次向后移动一位 for(int index=N;index&gt;i;index--){ eles[index]=eles[index-1]; } //再把t元素放到i索引处即可 eles[i]=t; //元素个数+1 N++; } //删除指定位置i处的元素，并返回该元素 public T remove(int i){ //记录索引i处的值 T current = eles[i]; //索引i后面元素依次向前移动一位即可 for(int index=i;index&lt;N-1;index++){ eles[index]=eles[index+1]; } //元素个数-1 N--; if (N&lt;eles.length/4){ resize(eles.length/2); } return current; } //查找t元素第一次出现的位置 public int indexOf(T t){ for(int i=0;i&lt;N;i++){ if (eles[i].equals(t)){ return i; } } return -1; } //根据参数newSize，重置eles的大小 public void resize(int newSize){ //定义一个临时数组，指向原数组 T[] temp=eles; //创建新数组 eles=(T[])new Object[newSize]; //把原数组的数据拷贝到新数组即可 for(int i=0;i&lt;N;i++){ eles[i]=temp[i]; } } @Override public Iterator&lt;T&gt; iterator() { return new SIterator(); } private class SIterator implements Iterator{ private int cusor; public SIterator(){ this.cusor=0; } @Override public boolean hasNext() { return cusor&lt;N; } @Override public Object next() { return eles[cusor++]; } }}","link":"/2021/01/21/%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%A1%BA%E5%BA%8F%E8%A1%A8/"},{"title":"线程池中终止任务","text":"待完善【1】关于线程池中终止任务【2】面试官：如何停止一个正在运行的线程？我又懵了","link":"/2021/08/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BB%88%E6%AD%A2%E4%BB%BB%E5%8A%A1/"},{"title":"线程池参数配置与Linux CPU","text":"1、线程池核心线程数配置1）核心线程计算 计算密集型：cpu的个数+1。 IO密集型：2*cpu个数 + 12）linux查看cpu核数 12345678查看物理CPU个数cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq逻辑CPU的个数 ，这个是我们的机器总的cpu的个数，也是设置线程池大小的时候考虑的cpu的个数。cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l 三者关系 物理cpu个数 * 每一个物理cup的个数 = 逻辑cpu的个数。 2个CPU,每个CPU有6个core,显示24，应该是Intel的CPU,支持超线程 参考博客【1】Linux下区分物理CPU、逻辑CPU和CPU核数【2】设置线程池大小和linux 查看cpu核数","link":"/2021/08/11/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8ELinux%20CPU/"},{"title":"结果集封装","text":"1234567891011121314151617181920212223242526272829303132333435@Datapublic class Result implements Serializable { private String code; private String msg; private Object data; public static Result succ(Object data) { Result m = new Result(); m.setCode(&quot;0&quot;); m.setData(data); m.setMsg(&quot;操作成功&quot;); return m; } public static Result succ(String mess, Object data) { Result m = new Result(); m.setCode(&quot;0&quot;); m.setData(data); m.setMsg(mess); return m; } public static Result fail(String mess) { Result m = new Result(); m.setCode(&quot;-1&quot;); m.setData(null); m.setMsg(mess); return m; } public static Result fail(String mess, Object data) { Result m = new Result(); m.setCode(&quot;-1&quot;); m.setData(data); m.setMsg(mess); return m; }}","link":"/2021/08/23/%E7%BB%93%E6%9E%9C%E9%9B%86%E5%B0%81%E8%A3%85/"},{"title":"自定义Spring IOC总结","text":"自定义Spring IOC总结 1、定义bean相关的pojo类 1）PropertyValue类 2）MutablePropertyValues类 3）BeanDefinition类 2、定义注册表相关类 1）BeanDefinitionRegistry接口 2）SimpleBeanDefinitionRegistry类 3、定义解析器相关类 1）BeanDefinitionReader接口 2）XmlBeanDefinitionReader类 4、IOC容器相关类 1）BeanFactory接口 2）ApplicationContext接口 3）AbstractApplicationContext类 4）ClassPathXmlApplicationContext类 5、使用到的设计模式 1、定义bean相关的pojo类1）PropertyValue类2）MutablePropertyValues类3）BeanDefinition类2、定义注册表相关类1）BeanDefinitionRegistry接口2）SimpleBeanDefinitionRegistry类3、定义解析器相关类1）BeanDefinitionReader接口2）XmlBeanDefinitionReader类4、IOC容器相关类1）BeanFactory接口2）ApplicationContext接口3）AbstractApplicationContext类4）ClassPathXmlApplicationContext类5、使用到的设计模式123456* 工厂模式。这个使用工厂模式 + 配置文件的方式。* 单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。* 模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。* 迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。","link":"/2021/08/15/%E8%87%AA%E5%AE%9A%E4%B9%89Spring%20IOC%E6%80%BB%E7%BB%93/"},{"title":"获取JSONObject中深层嵌套的key_value","text":"123//取出datas里的，data里的description JSONObject data = datas.getJSONObject(&quot;data&quot;); String description = data.get(&quot;description&quot;).toString(); 12345//取出datas里的，data里的，creator里的nameJSONObject data = datas.getJSONObject(&quot;data&quot;);JSONObject creator = data.getJSONObject(&quot;creator&quot;);String name = creator.get(&quot;name&quot;).toString(); 参考博客【1】java 获取JSONObject中key对应的值","link":"/2021/09/10/%E8%8E%B7%E5%8F%96JSONObject%E4%B8%AD%E6%B7%B1%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84key_value/"},{"title":"解决数据库存取时间的问题","text":"参考博客【1】：将时间写入数据库时,秒带小数点问题【2】：@JsonFormat与@DateTimeFormat注解的使用","link":"/2021/08/10/%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"计算机网络-第一章读书笔记","text":"一、一些基本概念端系统/主机：传统设备：传统的桌面PC、 Linux工作站以及所谓的服务 非传统设备：便携机、智能手机、平板电脑、电视、游戏机、 Web 相机、汽车、环境传感设备、数字相框、家用电器。这些设备都称为 主机( host) 或 端系统 (end syslem) 分组( packet)：当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节 由此形成的信息包。分组交换机：两种最著名的类型是路由器( router) 和链路层交换机( link-layer switch ） 通信链路：如同轴电缆、铜线、光纤和无线电频谱 123456789 分组交换机：两种最著名的类型是路由器( router) 和链路层交换机( link-layer switch ）分布式应用程序 (distri buted application)电子邮件、 Web 冲浪、即时讯息、杜交网络 、流式视频、分布式游戏等。因为它们涉及多台相互交换数据的端系统。","link":"/2021/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"记一次Idea jar包存在但是导入不进来","text":"搞得烦得一批，上次就出现这种情况 我的解决办法：Alt_Enter 找到添加依赖项 添加相应得依赖就可以了。。。。。","link":"/2021/07/08/%E8%AE%B0%E4%B8%80%E6%AC%A1Idea%20jar%E5%8C%85%E5%AD%98%E5%9C%A8%E4%BD%86%E6%98%AF%E5%AF%BC%E5%85%A5%E4%B8%8D%E8%BF%9B%E6%9D%A5/"},{"title":"设计模式总结","text":"设计模式总结 一、设计模式七大原则 二、类图的关系 三、设计模式 1、创建型设计模式 2、结构型设计模式 3、行为型设计模式 一、设计模式七大原则1、单一职责原则 对于类来说，一个类只负责一项职责。若一个类负责多个职责，则当一个职责发生变化，可能影响另一个职责功能正常使用2、接口隔离原则（Interface Segregation Principle） 一个类对另一个类的依赖应该建立在最小数量接口上，譬如类A 依赖（参数传递） 类B，而类B要实现接口1的全部方法，此时，接口1应该建立最小数量接口。若过多，则需要拆分。减少浪费。3、依赖倒置原则（Dependence Inversion Principle） 细节依赖抽象，而不是抽象依赖细节。中心思想上面向接口编程依赖关系传递的三种方式： 1）接口传递 2）构造方法传递 3）setter传递4、里氏替换原则（Lisko Substitution Principle） 主要针对继承 尽量不要修改父类的方法的功能 如要修改，可以通过组合，聚合，依赖来解决问题。5、开闭原则（Open Closed Principle）【重要，基础】 模块和功能对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节。6、迪米特原则（Demeter Principle） 最小知道原则降底类之间的耦合关系。 直接朋友：成员变量，方法参数，方法返回值。B类作为A类的成员变量，B类在A类的方法作为参数传递，B类作为Al类某方法的返回值。 不是直接朋友：局部变量。例如， B b = new B(); 存在于A类中。B在方法内部作为参数返回7、合成复用原则（Composite Reuse Principle） 尽量使用合成或聚合的方式，而不是使用继承。设计核心思想 1、找出可能发生变化的部分，将其独立出来，不要和那些不需要变化的代码混合在一起 2、针对接口编程，而不是针对实现编程 3、为交互对象之间的松耦合而努力。 二、类图的关系1、依赖关系（Dependency）类的成员属性、方法参数、返回类型等等 2、泛化关系-继承-依赖的特例（Generalization） 3、实现关系-依赖的特例（Realization） 4、关联关系（Association）一对一：单向、双向 5、聚合关系-关联特例（Aggregation）电脑和其配件，可以拆分 6、组合关系（composition）整体和部分，但是不可分离，比如人和脑袋。 12private IDcard idcard ; //聚合关系,但是级联关系，变为同生共死的关系，则为组合private Head head = new Head (); //组合关系 三、设计模式1、创建型设计模式创建型设计模式总结 2、结构型设计模式结构型设计模式总结 3、行为型设计模式行为型设计模式总结","link":"/2021/08/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"配置不同环境多个application.properties或application.yml","text":"【参考博客】【1】：profile根据不同环境打不同application.properties资源包","link":"/2021/08/11/%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%A4%9A%E4%B8%AAapplication.properties%E6%88%96application.yml/"},{"title":"队列","text":"队列 队列的基本结构 队列的基本结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.Iterator;public class Queue&lt;T&gt; implements Iterable&lt;T&gt;{ //记录首结点 private Node head; //记录最后一个结点 private Node last; //记录队列中元素的个数 private int N; private class Node{ public T item; public Node next; public Node(T item, Node next) { this.item = item; this.next = next; } } public Queue() { this.head = new Node(null,null); this.last=null; this.N=0; } //判断队列是否为空 public boolean isEmpty(){ return N==0; } //返回队列中元素的个数 public int size(){ return N; } //向队列中插入元素t public void enqueue(T t){ if (last==null){ //当前尾结点last为null last= new Node(t,null); head.next=last; }else { //当前尾结点last不为null Node oldLast = last; last = new Node(t, null); oldLast.next=last; } //元素个数+1 N++; } //从队列中拿出一个元素 public T dequeue(){ if (isEmpty()){ return null; } Node oldFirst= head.next; head.next=oldFirst.next; N--; //因为出队列其实是在删除元素，因此如果队列中的元素被删除完了，需要重置last=null; if (isEmpty()){ last=null; } return oldFirst.item; } @Override public Iterator&lt;T&gt; iterator() { return new QIterator(); } private class QIterator implements Iterator{ private Node n; public QIterator(){ this.n=head; } @Override public boolean hasNext() { return n.next!=null; } @Override public Object next() { n = n.next; return n.item; } }}","link":"/2021/01/29/%E9%98%9F%E5%88%97/"},{"title":"Java8新特性基本使用与应用场景","text":"Java8新特性基本使用与应用场景 一、基本使用 1、Lambda 1）语法格式一：无参，无返回值 2）语法格式二：一个参数，但是没有返回值。 3）语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断” 4）语法格式四：若只需要一个参数时，参数的小括号可以省略 5）语法格式五：需要两个或以上的参数，多条执行语句，并且可以有返回值 6）语法格式六：只有一条语句时，return 与大括号若有，都可以省略 2、方法引用 1）情况一：对象 :: 实例方法 2）情况二：类 :: 静态方法 3）情况三：类 :: 实例方法 （有难度） 3、构造器和数组引用 1）构造器引用 2）数组引用 4、Stream 1）概述 2）使用 1、创建Stream的四种方式 2、中间操作（筛选与切片、映射、排序） 3、终止操作 二、应用场景 一、基本使用1、Lambda1）语法格式一：无参，无返回值12Runnable run2 = () -&gt; {System.out.println(&quot;无参，无返回值&quot;);};run2.run(); 2）语法格式二：一个参数，但是没有返回值。12Consumer&lt;String&gt; com2 = (String t) -&gt;{System.out.println(t);};com2.accept(&quot;一个参数，但是没有返回值&quot;); 3）语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”12Consumer&lt;String&gt; com2 = (t) -&gt;{System.out.println(t);};com2.accept(&quot;数据类型可以省略，因为可由编译器推断得出，称为“类型推断”&quot;); 4）语法格式四：若只需要一个参数时，参数的小括号可以省略12Consumer&lt;String&gt; com2 = t -&gt;{System.out.println(t);};com2.accept(&quot;数据类型可以省略，因为可由编译器推断得出，称为“类型推断”&quot;); 5）语法格式五：需要两个或以上的参数，多条执行语句，并且可以有返回值1234567Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; { System.out.println(o1); System.out.println(o2); return Integer.compare(o1, o2); }; int value1 = com1.compare(12, 21); System.out.println(value1); 6）语法格式六：只有一条语句时，return 与大括号若有，都可以省略123Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1, o2);int value1 = com2.compare(12, 21);System.out.println(value1); 【总结】左边：Lambda形参列表的参数类型可以忽略，如果只有一个参数，() 可以忽略右边：Lambda体应该由 { } 所包裹，若体中只有一条语句也包括return语句，可以省略 { } 和 return 函数式接口：如果一个接口中只声明了一个抽象方法，称为函数式接口 2、方法引用【要求】：函数式接口中抽象方法的形参列表和返回值类型 要与 方法引用对应的方法的形参列表和返回值类型一致！三种情况对象 :: 实例方法类 :: 静态方法类 :: 实例方法 （有难度） 1）情况一：对象 :: 实例方法12345678910// void accept(T t)//PrintStream类中 void println(T t) Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str); con1.accept(&quot;beijing&quot;); System.out.println(&quot;***************&quot;); PrintStream ps = System.out; Consumer&lt;String&gt; con2 = ps :: println; con2.accept(&quot;beijing&quot;); 2）情况二：类 :: 静态方法12345678910111213141516171819202122//R compare(T t1,T2)// Integer中的静态方法：R compare(T t1,T t2) Comparator&lt;Integer&gt; com = (num1, num2) -&gt; Integer.compare(num1, num2); int value = com.compare(12, 32); System.out.println(value); System.out.println(&quot;***************&quot;); Comparator&lt;Integer&gt; com1 = Integer :: compare; int value1 = com1.compare(12, 32); System.out.println(value1);//R apply(T t)//Math类的静态方法：long round(double d) Function&lt;Double, Long&gt; func1 = d -&gt; Math.round(d); Long value = func1.apply(12.3); System.out.println(value); System.out.println(&quot;***************&quot;); Function&lt;Double, Long&gt; func2 = Math::round; value = func2.apply(12.3); System.out.println(value); 3）情况三：类 :: 实例方法 （有难度）1234567891011121314151617181920212223242526272829303132333435//R compare(T t1, T t2)//t1.非静态方法(t2) Comparator&lt;String&gt; com = (s1, s2) -&gt; s1.compareTo(s2); int value = com.compare(&quot;abad&quot;, &quot;abdd&quot;); System.out.println(value); System.out.println(&quot;***************&quot;); Comparator&lt;String&gt; com1 = String :: compareTo; value = com1.compare(&quot;abad&quot;, &quot;abdd&quot;); System.out.println(value);//boolean test(T t1, T t2)//t1.非静态方法(t2) BiPredicate&lt;String, String&gt; bi = (s1, s2) -&gt; s1.equals(s2); boolean b = bi.test(&quot;abc&quot;, &quot;abc&quot;); System.out.println(b); System.out.println(&quot;***************&quot;); BiPredicate&lt;String, String&gt; bi1 = String :: equals; b = bi1.test(&quot;abc&quot;, &quot;abc&quot;); System.out.println(b); //R apply(T t)//t.非静态方法() Employee emp = new Employee(1001, &quot;Jerry&quot;, 32, 23430); Function&lt;Employee, String&gt; func1 = (e) -&gt; e.getName(); String name = func1.apply(emp); System.out.println(name); System.out.println(&quot;***************&quot;); Function&lt;Employee, String&gt; func2 = Employee::getName; name = func2.apply(emp); System.out.println(name); 3、构造器和数组引用1）构造器引用【格式】： 类名 :: new【要求】：函数式接口中抽象方法的形参列表与构造器形参列表一致（类型相同，个数相同），同时，抽象方法的返回值类型即为构造器所属的类的类型。 123456789101112131415Supplier&lt;Employee&gt; sup = () -&gt; new Employee();Employee emp = sup.get();System.out.println(emp);System.out.println(&quot;**********&quot;);Supplier&lt;Employee&gt; sup1 = Employee :: new;/*=======================================================================*/BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; new Employee(id,name);Employee emp = func1.apply(10, &quot;Jim&quot;);System.out.println(emp);System.out.println(&quot;**********&quot;);BiFunction&lt;Integer,String,Employee&gt; func2 = Employee ::new; 2）数组引用1234567Function&lt;Integer,String[]&gt; func1 = (length) -&gt; new String[length];String[] arr = func1.apply(10);System.out.println(arr.length);System.out.println(&quot;**********&quot;);Function&lt;Integer,String[]&gt; func12 = String[] ::new; 4、Stream1）概述1.Stream API: java提供一套api（java.util.stream），使用这套api可以实现对数组、集合数据的过滤、归约、合并等操作。2.注意点： 123①Stream 自己不会存储元素。②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 ③Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 3.Stream的使用流程： 123步骤一：Stream的实例化 步骤二：一系列的中间操作 步骤三：终止操作 注意： 123①步骤二中的中间操作可以有多个 ②如果没有终止操作，那么一系列的中间操作是不会执行的。只有执行了步骤三的终止操作，步骤二才会执行：惰性求值③终止操作一旦执行，就不可以再执行中间操作或其他的终止操作。 2）使用1、创建Stream的四种方式方式一：通过集合 123456// default Stream&lt;E&gt; stream() : 返回一个顺序流List&lt;Employee&gt; list = EmployeeData.getEmployees();Stream&lt;Employee&gt; stream = list.stream();// default Stream&lt;E&gt; parallelStream() : 返回一个并行流Stream&lt;Employee&gt; stream1 = list.parallelStream(); 方式二：通过数组 123// 调用Arrays的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流String[] arr = new String[] { &quot;MM&quot;, &quot;GG&quot;, &quot;JJ&quot;, &quot;DD&quot; };Stream&lt;String&gt; stream = Arrays.stream(arr); 方式三：Stream的静态方法of() 12// public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5); 方式四：创建无限流 123456789// 迭代// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final// UnaryOperator&lt;T&gt; f)Stream&lt;Integer&gt; stream = Stream.iterate(0, x -&gt; x + 2);stream.limit(10).forEach(System.out::println);// 生成// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);stream1.limit(10).forEach(System.out::println); 2、中间操作（筛选与切片、映射、排序）1）筛选与切片【filter】【limit】【skip】【distinct】 1234567891011121314151617List&lt;Employee&gt; list = EmployeeData.getEmployees();1、// filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。list.stream().filter(e -&gt; e.getAge() &gt; 30).forEach(System.out::println);2、// limit(n)——截断流，使其元素不超过给定数量。list.stream().filter(e -&gt; e.getAge() &gt; 30).limit(3).forEach(System.out::println);3、//skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补list.stream().filter(e -&gt; e.getAge() &gt; 30).skip(3).forEach(System.out::println);4、//distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素list.add(new Employee(1009,&quot;小王&quot;,30,6000));list.add(new Employee(1009,&quot;小王&quot;,30,6000));list.add(new Employee(1009,&quot;小王&quot;,30,6000));list.add(new Employee(1009,&quot;小王&quot;,30,6000));list.add(new Employee(1009,&quot;小王&quot;,30,6000));list.stream().distinct().forEach(System.out::println); 2）映射1、【map(Function f)】——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。 123456 List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;); list.stream().map(String::toUpperCase).forEach(System.out::println);//练习：获取员工姓名长度大于3的员工的姓名。 Stream&lt;Employee&gt; stream = EmployeeData.getEmployees().stream(); Stream&lt;String&gt; stream1 = stream.map(Employee::getName); stream1.filter(name -&gt; name.length() &gt; 3).forEach(System.out::println); 2、【flatMap(Function f)】——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。 12Stream&lt;Character&gt; stream3 = list.stream().flatMap(StreamAPITest1::fromStringToChar);stream3.forEach(System.out::println); 3）排序1、sorted()——自然排序 12345 List&lt;Integer&gt; list = Arrays.asList(23,43,454,32,1,2,5,5,-8); list.stream().sorted().forEach(System.out::println);//此时针对Employees进行排序：失败。原因：Employee类没有实现Comparable接口// List&lt;Employee&gt; list1 = EmployeeData.getEmployees();// list1.stream().sorted().forEach(System.out::println); 2、sorted(Comparator com)——定制排序 12345678List&lt;Employee&gt; list1 = EmployeeData.getEmployees();list1.stream().sorted((e1,e2) -&gt; { if(e1.getAge() != e2.getAge()){ return e1.getAge() - e2.getAge(); }else{ return -Double.compare(e1.getSalary(),e2.getSalary()); }}).forEach(System.out::println); 3、终止操作1）匹配与查找【max】【min】 1234567891011121314List&lt;Employee&gt; list = EmployeeData.getEmployees();// max(Comparator c)——返回流中最大值1、练习：返回最高的工资： Stream&lt;Employee&gt; stream = list.stream(); Stream&lt;Double&gt; stream1 = stream.map(Employee::getSalary); Optional&lt;Double&gt; max = stream1.max(Double::compare); System.out.println(max.get());// min(Comparator c)——返回流中最小值2、练习：返回最低工资的员工 Stream&lt;Employee&gt; stream2 = list.stream(); Optional&lt;Employee&gt; min = stream2.min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(min.get());3、forEach(Consumer c)——内部迭代 list.stream().forEach(System.out::println); 【allMatch】【noneMatch】【sorted】【findFirst】【count】 12345678910111213141516171819202122232425262728List&lt;Employee&gt; list = EmployeeData.getEmployees();// allMatch(Predicate p)——检查是否匹配所有元素// 是否所有的员工的年龄都大于18 boolean b = list.stream().allMatch(e -&gt; e.getAge() &gt; 18); System.out.println(b);// anyMatch(Predicate p)——检查是否至少匹配一个元素// 是否存在员工的工资大于 10000 boolean b1 = list.stream().anyMatch(e -&gt; e.getSalary() &gt; 9900); System.out.println(b1);// noneMatch(Predicate p)——检查是否没有匹配的元素// 是否存在员工姓“雷” boolean b2 = list.stream().noneMatch(e -&gt; e.getName().contains(&quot;雷&quot;)); System.out.println(b2);// findFirst——返回第一个元素 Optional&lt;Employee&gt; emp = list.stream().sorted((e1, e2) -&gt; { if (e1.getAge() != e2.getAge()) { return e1.getAge() - e2.getAge(); } else { return -Double.compare(e1.getSalary(), e2.getSalary()); } }).findFirst(); System.out.println(emp.get());// findAny——返回当前流中的任意元素 Optional&lt;Employee&gt; emp1 = list.parallelStream().findAny(); System.out.println(emp1.get());// count——返回流中元素的总个数 long count = list.stream().filter(e -&gt; e.getSalary() &gt; 5000).count(); System.out.println(count); 2） 归约【reduce】 123456789101112131415161718192021222324252627282930313233// reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6); // Integer sum = list.stream().reduce(0, (x1, x2) -&gt; x1 + x2); Integer sum = list.stream().reduce(10, Integer::sum); // reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt; // 练习1：计算公司所有员工工资的总和 List&lt;Employee&gt; emps = EmployeeData.getEmployees(); Stream&lt;Double&gt; moneyStream = emps.stream().map(Employee::getSalary); Optional&lt;Double&gt; moneyOptional = moneyStream.reduce(Double::sum); System.out.println(moneyOptional.get()); // 练习2：员工姓名中包含“马”字的个数 Stream&lt;String&gt; nameStream = emps.stream().map(Employee::getName); Stream&lt;Character&gt; charStream = nameStream.flatMap(StreamAPITest1::fromStringToChar); // 方式一： // long count = charStream.filter(c -&gt; c.equals('马')).count(); // System.out.println(count); // 方式二： Optional&lt;Integer&gt; op = charStream.map(c -&gt; { if (c.equals('马')) { return 1; } else { return 0; } }).reduce(Integer::sum); System.out.println(op.get()); // 练习3：员工姓名中包含“马”的员工个数 long count = emps.stream().map(Employee::getName).filter(name -&gt; name.contains(&quot;马&quot;)).count(); // 练习4：员工姓名中包含“马”的员工的姓名 emps.stream().map(Employee::getName).filter(name -&gt; name.contains(&quot;马&quot;)).forEach(System.out::println); 3）终止操作【collect】 123456789101112131415// collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，// 用于给Stream中元素做汇总的方法List&lt;Employee&gt; list = EmployeeData.getEmployees();List&lt;Employee&gt; list1 = list.stream().filter(e -&gt; e.getSalary() &gt; 5000).collect(Collectors.toList());// 遍历list1.forEach(System.out::println);//==============================================================Set&lt;Employee&gt; set = list.stream().filter(e -&gt; e.getSalary() &gt; 5000).collect(Collectors.toSet());set.forEach(System.out::println); ArrayList&lt;Employee&gt; list2 = list.stream().filter(e -&gt; e.getSalary() &gt; 5000) .collect(Collectors.toCollection(ArrayList::new));for (Employee employee : list2) { System.out.println(employee);} 二、应用场景","link":"/2021/07/26/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"},{"title":"创建型设计模式总结","text":"创建型设计模式 1、单例模式 1.1 饿汉式 （静态常量） 1.2 饿汉式（静态代码块） 1.3 懒汉式 线程不安全 1.4 懒汉式 线程安全，同步方法 1.5 懒汉式 线程安全，同步代码块 1.6 双重检查【推荐】 1.7 静态内部类【推荐】 1.8 枚举【推荐】 2、工厂模式（简单工厂、工厂方法、抽象工厂） 2.1 简单工厂 2.2 工厂方法 2.3 抽象工厂 2.4 工作中常用工厂模式的形式 3、原型模式 4、建造者模式 5、创建者模式对比 5.1 工厂方法模式VS建造者模式 5.2 抽象工厂模式VS建造者模式 1、单例模式 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例 ，并且该类只提供一个取得其对象实例的方法静态方法 。 1.1 饿汉式 （静态常量） 结论：可用，类加载时创建，可能造成内存浪费。 1234567891011class Singleton { //1. 构造器私有化, 外部能new private Singleton() { } //2.本类内部创建对象实例 private final static Singleton instance = new Singleton(); //3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; }} 1.2 饿汉式（静态代码块） 结论：同上 1234567891011121314class Singleton { //1. 构造器私有化, 外部能new private Singleton() { } //2.本类内部创建对象实例 private static Singleton instance; static { // 在静态代码块中，创建单例对象 instance = new Singleton(); } //3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() { return instance; }} 1.3 懒汉式 线程不安全 结论：线程不安全，当两个线程都进入if判断，则创建两个实例。不是单例。 123456789101112class Singleton { private static Singleton instance; private Singleton() {} //提供一个静态的公有方法，当使用到该方法时，才去创建 instance //即懒汉式 public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; }} 1.4 懒汉式 线程安全，同步方法 结论：线程安全，效率低。 12345678910111213// 懒汉式(线程安全，同步方法)class Singleton { private static Singleton instance; private Singleton() {} //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 //即懒汉式 public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; }} 1.5 懒汉式 线程安全，同步代码块 错误，同1.1.3 线程不安全，两个线程都进入if判断，则创建两个实例。不是单例。 1.6 双重检查【推荐】 结论：推荐该方法 1234567891011121314151617// 懒汉式(线程安全，同步方法)class Singleton { private static volatile Singleton instance; private Singleton() {} //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题 //同时保证了效率, 推荐使用 public static Singleton getInstance() { if(instance == null) { synchronized (Singleton.class) { if(instance == null) { instance = new Singleton(); } } } return instance; }} 1.7 静态内部类【推荐】 结论：推荐使用 1、采用了类装载的机制来保证初始化实例时只有一个线程 。 2、静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载。JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的 。 1234567891011121314// 静态内部类完成， 推荐使用class Singleton { private static volatile Singleton instance; //构造器私有化 private Singleton() {} //写一个静态内部类,该类中有一个静态属性 Singleton private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE public static synchronized Singleton getInstance() { return SingletonInstance.INSTANCE; }} 1.8 枚举【推荐】 结论：推荐使用。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 1234567//使用枚举，可以实现单例, 推荐enum Singleton { INSTANCE; //属性 public void sayOK() { System.out.println(&quot;ok~&quot;); }} 2、工厂模式（简单工厂、工厂方法、抽象工厂）2.1 简单工厂【概念】：简单工厂模式是由一个工厂对象决定创建出哪一 种产品类 的实例 。简单工厂模式是工厂模式家族中最简单实用的模式【结构】：抽象产品：定义了产品的规范，描述了产品的主要特性和功能。 具体产品：实现或者继承抽象产品的子类 具体工厂：提供了创建产品的方法，调用者通过该方法来获取产品。【缺点】：增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。【实现】： 1234567891011public class SimpleCoffeeFactory { public Coffee createCoffee(String type) { Coffee coffee = null; if(&quot;americano&quot;.equals(type)) { coffee = new AmericanoCoffee(); } else if(&quot;latte&quot;.equals(type)) { coffee = new LatteCoffee(); } return coffee; }} 静态工厂模式 1234567891011public class SimpleCoffeeFactory { public static Coffee createCoffee(String type) { Coffee coffee = null; if(&quot;americano&quot;.equals(type)) { coffee = new AmericanoCoffee(); } else if(&quot;latte&quot;.equals(type)) { coffee = new LatteCoffee(); } return coffe; }} 2.2 工厂方法【概念】：定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。【结构】：抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。【缺点】：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。产生类爆炸。【实现】： 12345678910111213141516171819202122232425262728//抽象工厂public interface CoffeeFactory { Coffee createCoffee();}//具体工厂public class LatteCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new LatteCoffee(); }}public class AmericanCoffeeFactory implements CoffeeFactory { public Coffee createCoffee() { return new AmericanCoffee(); }}//咖啡店类：public class CoffeeStore { private CoffeeFactory factory; public CoffeeStore(CoffeeFactory factory) { this.factory = factory; } public Coffee orderCoffee() { Coffee coffee = factory.createCoffee(); coffee.addMilk(); coffee.addsugar(); return coffee; }} 2.3 抽象工厂【概念】：抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。【缺点】：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。【结构】：抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。【实现】： 123456789101112131415161718192021222324//抽象工厂public interface DessertFactory { Coffee createCoffee(); Dessert createDessert();}//具体工厂//美式甜点工厂public class AmericanDessertFactory implements DessertFactory { public Coffee createCoffee() { return new AmericanCoffee(); } public Dessert createDessert() { return new MatchaMousse(); }}//意大利风味甜点工厂public class ItalyDessertFactory implements DessertFactory { public Coffee createCoffee() { return new LatteCoffee(); } public Dessert createDessert() { return new Tiramisu(); }} 2.4 工作中常用工厂模式的形式简单工厂+配置文件解除耦合工作实际开发中用到的工厂模式形式 3、原型模式【概念】：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。【结构】：抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。【分类】：浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型的属性，仍指向原有属性所指向的对象的内存地址。 深克隆：创建一个新对象，属性中引用的其他对象的属性也会被克隆，不再指向原有对象地址。【实现】：1、浅克隆 1234567891011121314151617181920212223242526272829303132333435//奖状类public class Citation implements Cloneable { private Student stu; public Student getStu() { return stu; } public void setStu(Student stu) { this.stu = stu; } void show() { System.out.println(stu.getName() + &quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;); } @Override public Citation clone() throws CloneNotSupportedException { return (Citation) super.clone(); }}//测试类public class CitationTest { public static void main(String[] args) throws CloneNotSupportedException { Citation c1 = new Citation(); Student stu = new Student(&quot;张三&quot;, &quot;西安&quot;); c1.setStu(stu); //复制奖状 Citation c2 = c1.clone(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(&quot;李四&quot;); //判断stu对象和stu1对象是否是同一个对象 System.out.println(&quot;stu和stu1是同一个对象？&quot; + (stu == stu1)); c1.show(); c2.show(); }} 2、深克隆 1234567891011121314151617181920212223public class CitationTest1 { public static void main(String[] args) throws Exception { Citation c1 = new Citation(); Student stu = new Student(&quot;张三&quot;, &quot;西安&quot;); c1.setStu(stu); //创建对象输出流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt&quot;)); //将c1对象写出到文件中 oos.writeObject(c1); oos.close(); //创建对象出入流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt&quot;)); //读取对象 Citation c2 = (Citation) ois.readObject(); //获取c2奖状所属学生对象 Student stu1 = c2.getStu(); stu1.setName(&quot;李四&quot;); //判断stu对象和stu1对象是否是同一个对象 System.out.println(&quot;stu和stu1是同一个对象？&quot; + (stu == stu1)); c1.show(); c2.show(); }} 4、建造者模式【概念】：将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。如cpu、内存条以及显示屏等 与 组装好电脑。【结构】：抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 产品类（Product）：要创建的复杂对象。 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。【缺点】：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。【实现】： 1、抽象建造者类（Builder）： 1234567// 抽象 builder 类public abstract class Builder { protected Bike mBike = new Bike();//允许子类继承 public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike();} 2、具体建造者类（ConcreteBuilder） 1234567891011121314public class MobikeBuilder extends Builder { @Override public void buildFrame() { mBike.setFrame(&quot;铝合金车架&quot;); } @Override public void buildSeat() { mBike.setSeat(&quot;真皮车座&quot;); } @Override public Bike createBike() { return mBike; }} 3、指挥者类（Director） 123456789101112//指挥者类public class Director { private Builder mBuilder; public Director(Builder builder) { mBuilder = builder; } public Bike construct() { mBuilder.buildFrame(); mBuilder.buildSeat(); return mBuilder.createBike(); }} 4、简化系统结构，可以把指挥者类和抽象建造者进行结合 123456789101112// 抽象 builder 类public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); public Bike construct() { this.buildFrame(); this.BuildSeat(); return this.createBike(); }} 【链式调用】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Phone { private String cpu; private String screen; private String memory; private String mainboard; private Phone(Builder builder) { cpu = builder.cpu; screen = builder.screen; memory = builder.memory; mainboard = builder.mainboard; } public static final class Builder { private String cpu; private String screen; private String memory; private String mainboard; public Builder() {} public Builder cpu(String val) { cpu = val; return this; } public Builder screen(String val) { screen = val; return this; } public Builder memory(String val) { memory = val; return this; } public Builder mainboard(String val) { mainboard = val; return this; } public Phone build() { return new Phone(this);} } @Override public String toString() { return &quot;Phone{&quot; + &quot;cpu='&quot; + cpu + '\\'' + &quot;, screen='&quot; + screen + '\\'' + &quot;, memory='&quot; + memory + '\\'' + &quot;, mainboard='&quot; + mainboard + '\\'' + '}'; }}public class Client { public static void main(String[] args) { Phone phone = new Phone.Builder() .cpu(&quot;intel&quot;) .mainboard(&quot;华硕&quot;) .memory(&quot;金士顿&quot;) .screen(&quot;三星&quot;) .build(); System.out.println(phone); }} 5、创建者模式对比5.1 工厂方法模式VS建造者模式 工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。 我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。 5.2 抽象工厂模式VS建造者模式","link":"/2021/08/07/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"结构型设计模式总结","text":"结构型设计模式 1、代理模式 1.1 静态代理 1.2 动态代理 1.2.1 JDK动态代理 1.2.2 CGLIB动态代理 2、适配器模式 2.1 类适配器 2.2 对象适配器 3、装饰器模式 4、桥接模式 5、外观模式 6、组合模式 7、享元模式 1、代理模式【概念】：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。【结构】：抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。 1.1 静态代理【缺点】：如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。【实现】： 12345678910111213141516171819202122232425//卖票接口public interface SellTickets { void sell();}//火车站 火车站具有卖票功能，所以需要实现SellTickets接口public class TrainStation implements SellTickets { public void sell() { System.out.println(&quot;火车站卖票&quot;); }}//代售点public class ProxyPoint implements SellTickets { private TrainStation station = new TrainStation(); public void sell() { System.out.println(&quot;代理点收取一些服务费用&quot;); station.sell(); }}//测试类public class Client { public static void main(String[] args) { ProxyPoint pp = new ProxyPoint(); pp.sell(); }} 1.2 动态代理1.2.1 JDK动态代理【缺点】：增加了系统的复杂度；【实现】： 12345678910111213141516171819202122232425262728293031323334353637//卖票接口public interface SellTickets { void sell();}//火车站 火车站具有卖票功能，所以需要实现SellTickets接口public class TrainStation implements SellTickets { public void sell() { System.out.println(&quot;火车站卖票&quot;); }}//代理工厂，用来创建代理对象public class ProxyFactory { private TrainStation station = new TrainStation(); public SellTickets getProxyObject() { SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance( station.getClass().getClassLoader(), station.getClass().getInterfaces(), new InvocationHandler() { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;); //执行真实对象 Object result = method.invoke(station, args); return result; } }); return sellTickets; }}//测试类public class Client { public static void main(String[] args) { //获取代理对象 ProxyFactory factory = new ProxyFactory(); SellTickets proxyObject = factory.getProxyObject(); proxyObject.sell(); }} 1.2.2 CGLIB动态代理【缺点】：增加了系统的复杂度；【实现】： 12345678910111213141516171819202122232425262728293031323334353637383940414243/火车站public class TrainStation { public void sell() { System.out.println(&quot;火车站卖票&quot;); }}//代理工厂public class ProxyFactory implements MethodInterceptor { private TrainStation target = new TrainStation(); public TrainStation getProxyObject() { //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(target.getClass()); //设置回调函数 enhancer.setCallback(this); //创建代理对象 TrainStation obj = (TrainStation) enhancer.create(); return obj; } /* intercept方法参数说明： o ： 代理对象 method ： 真实对象中的方法的Method实例 args ： 实际参数 methodProxy ：代理对象中的方法的method实例 */ public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;); TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args); return result; }}//测试类public class Client { public static void main(String[] args) { //创建代理工厂对象 ProxyFactory factory = new ProxyFactory(); //获取代理对象 TrainStation proxyObject = factory.getProxyObject(); proxyObject.sell(); }} 2、适配器模式【案例】：插座、转换器、插头【概述】：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。【结构】：目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 2.1 类适配器【缺点】：类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。【实现】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//SD卡的接口public interface SDCard { //读取SD卡方法 String readSD(); //写入SD卡功能 void writeSD(String msg);}//SD卡实现类public class SDCardImpl implements SDCard { public String readSD() { String msg = &quot;sd card read a msg :hello word SD&quot;; return msg; } public void writeSD(String msg) { System.out.println(&quot;sd card write msg : &quot; + msg); }}//电脑类public class Computer { public String readSD(SDCard sdCard) { if(sdCard == null) { throw new NullPointerException(&quot;sd card null&quot;); } return sdCard.readSD(); }}//TF卡接口public interface TFCard { //读取TF卡方法 String readTF(); //写入TF卡功能 void writeTF(String msg);}//TF卡实现类public class TFCardImpl implements TFCard { public String readTF() { String msg =&quot;tf card read msg : hello word tf card&quot;; return msg; } public void writeTF(String msg) { System.out.println(&quot;tf card write a msg : &quot; + msg); }}//定义适配器类（SD兼容TF）public class SDAdapterTF extends TFCardImpl implements SDCard { public String readSD() { System.out.println(&quot;adapter read tf card &quot;); return readTF(); } public void writeSD(String msg) { System.out.println(&quot;adapter write tf card&quot;); writeTF(msg); }}//测试类public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(&quot;------------&quot;); SDAdapterTF adapter = new SDAdapterTF(); System.out.println(computer.readSD(adapter)); }} 2.2 对象适配器【应用场景】：以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。【注意】：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。【实现】：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。 123456789101112131415161718192021222324252627//创建适配器对象（SD兼容TF）public class SDAdapterTF implements SDCard { private TFCard tfCard; public SDAdapterTF(TFCard tfCard) { this.tfCard = tfCard; } public String readSD() { System.out.println(&quot;adapter read tf card &quot;); return tfCard.readTF(); } public void writeSD(String msg) { System.out.println(&quot;adapter write tf card&quot;); tfCard.writeTF(msg); }}//测试类public class Client { public static void main(String[] args) { Computer computer = new Computer(); SDCard sdCard = new SDCardImpl(); System.out.println(computer.readSD(sdCard)); System.out.println(&quot;------------&quot;); TFCard tfCard = new TFCardImpl(); SDAdapterTF adapter = new SDAdapterTF(tfCard); System.out.println(computer.readSD(adapter)); }} 【JDK源码应用】：Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。 3、装饰器模式【案例】：炒饭、炒面加鸡蛋、火腿等【结构】：抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。【实现】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//快餐接口public abstract class FastFood { private float price; private String desc; public FastFood() { } public FastFood(float price, String desc) { this.price = price; this.desc = desc; } public void setPrice(float price) { this.price = price; } public float getPrice() { return price; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public abstract float cost(); //获取价格}//炒饭public class FriedRice extends FastFood { public FriedRice() { super(10, &quot;炒饭&quot;); } public float cost() { return getPrice(); }}//炒面public class FriedNoodles extends FastFood { public FriedNoodles() { super(12, &quot;炒面&quot;); } public float cost() { return getPrice(); }}//配料类public abstract class Garnish extends FastFood { private FastFood fastFood; public FastFood getFastFood() { return fastFood; } public void setFastFood(FastFood fastFood) { this.fastFood = fastFood; } public Garnish(FastFood fastFood, float price, String desc) { super(price,desc); this.fastFood = fastFood; }}//鸡蛋配料public class Egg extends Garnish { public Egg(FastFood fastFood) { super(fastFood,1,&quot;鸡蛋&quot;); } public float cost() { return getPrice() + getFastFood().getPrice(); } @Override public String getDesc() { return super.getDesc() + getFastFood().getDesc(); }}//培根配料public class Bacon extends Garnish { public Bacon(FastFood fastFood) { super(fastFood,2,&quot;培根&quot;); } @Override public float cost() { return getPrice() + getFastFood().getPrice(); } @Override public String getDesc() { return super.getDesc() + getFastFood().getDesc(); }}//测试类public class Client { public static void main(String[] args) { //点一份炒饭 FastFood food = new FriedRice(); //花费的价格 System.out.println(food.getDesc() + &quot; &quot; + food.cost() + &quot;元&quot;); System.out.println(&quot;========&quot;); //点一份加鸡蛋的炒饭 FastFood food1 = new FriedRice(); food1 = new Egg(food1); //花费的价格 System.out.println(food1.getDesc() + &quot; &quot; + food1.cost() + &quot;元&quot;); System.out.println(&quot;========&quot;); //点一份加培根的炒面 FastFood food2 = new FriedNoodles(); food2 = new Bacon(food2); //花费的价格 System.out.println(food2.getDesc() + &quot; &quot; + food2.cost() + &quot;元&quot;); }} 4、桥接模式【案例】：创建不同的图形，并且每个图形都有可能会有不同的颜色**/**视频播放器【使用场景】：当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。【概述】：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。【结构】：抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。【实现】： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//视频文件public interface VideoFile { void decode(String fileName);}//avi文件public class AVIFile implements VideoFile { public void decode(String fileName) { System.out.println(&quot;avi视频文件：&quot;+ fileName); }}//rmvb文件public class REVBBFile implements VideoFile { public void decode(String fileName) { System.out.println(&quot;rmvb文件：&quot; + fileName); }}//操作系统版本public abstract class OperatingSystemVersion { protected VideoFile videoFile; public OperatingSystemVersion(VideoFile videoFile) { this.videoFile = videoFile; } public abstract void play(String fileName);}//Windows版本public class Windows extends OperatingSystem { public Windows(VideoFile videoFile) { super(videoFile); } public void play(String fileName) { videoFile.decode(fileName); }}//mac版本public class Mac extends OperatingSystemVersion { public Mac(VideoFile videoFile) { super(videoFile); } public void play(String fileName) { videoFile.decode(fileName); }}//测试类public class Client { public static void main(String[] args) { OperatingSystem os = new Windows(new AVIFile()); os.play(&quot;战狼3&quot;); }} 5、外观模式【案例】：基金和基金经理 | 智能家居语音控制【概述】：又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。【引用场景】：对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。【结构】：外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。【实现】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//灯类public class Light { public void on() { System.out.println(&quot;打开了灯....&quot;); } public void off() { System.out.println(&quot;关闭了灯....&quot;); }}//电视类public class TV { public void on() { System.out.println(&quot;打开了电视....&quot;); } public void off() { System.out.println(&quot;关闭了电视....&quot;); }}//控制类public class AirCondition { public void on() { System.out.println(&quot;打开了空调....&quot;); } public void off() { System.out.println(&quot;关闭了空调....&quot;); }}//智能音箱public class SmartAppliancesFacade { private Light light; private TV tv; private AirCondition airCondition; public SmartAppliancesFacade() { light = new Light(); tv = new TV(); airCondition = new AirCondition(); } public void say(String message) { if(message.contains(&quot;打开&quot;)) { on(); } else if(message.contains(&quot;关闭&quot;)) { off(); } else { System.out.println(&quot;我还听不懂你说的！！！&quot;); } } //起床后一键开电器 private void on() { System.out.println(&quot;起床了&quot;); light.on(); tv.on(); airCondition.on(); } //睡觉一键关电器 private void off() { System.out.println(&quot;睡觉了&quot;); light.off(); tv.off(); airCondition.off(); }}//测试类public class Client { public static void main(String[] args) { //创建外观对象 SmartAppliancesFacade facade = new SmartAppliancesFacade(); //客户端直接与外观对象进行交互 facade.say(&quot;打开家电&quot;); facade.say(&quot;关闭家电&quot;); }} 【JDK源码应用】：[tomcat]、[ServletRequest]、[HttpServletRequest]、[RequestFacade]、[Request] 6、组合模式【案例】：软件树形菜单【概述】：又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。【结构】：抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。【实现】： 菜单组件 MenuComponent 123456789101112131415161718192021222324//菜单组件 不管是菜单还是菜单项，都应该继承该类public abstract class MenuComponent { protected String name; protected int level; //添加菜单 public void add(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } //移除菜单 public void remove(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } //获取指定的子菜单 public MenuComponent getChild(int i){ throw new UnsupportedOperationException(); } //获取菜单名称 public String getName(){ return name; } public void print(){ throw new UnsupportedOperationException(); }} 菜单Menu 123456789101112131415161718192021222324252627282930public class Menu extends MenuComponent { private List&lt;MenuComponent&gt; menuComponentList; public Menu(String name,int level){ this.level = level; this.name = name; menuComponentList = new ArrayList&lt;MenuComponent&gt;(); } @Override public void add(MenuComponent menuComponent) { menuComponentList.add(menuComponent); } @Override public void remove(MenuComponent menuComponent) { menuComponentList.remove(menuComponent); } @Override public MenuComponent getChild(int i) { return menuComponentList.get(i); } @Override public void print() { for (int i = 1; i &lt; level; i++) { System.out.print(&quot;--&quot;); } System.out.println(name); for (MenuComponent menuComponent : menuComponentList) { menuComponent.print(); } }} 菜单项 MenuItem 12345678910111213public class MenuItem extends MenuComponent { public MenuItem(String name,int level) { this.name = name; this.level = level; } @Override public void print() { for (int i = 1; i &lt; level; i++) { System.out.print(&quot;--&quot;); } System.out.println(name); }} 7、享元模式【案例】：俄罗斯方块【概述】：运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。【结构】：抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。【实现】：抽象享元角色（Flyweight） 123456public abstract class AbstractBox { public abstract String getShape(); public void display(String color) { System.out.println(&quot;方块形状：&quot; + this.getShape() + &quot; 颜色：&quot; + color); }} 具体享元（Concrete Flyweight）角色 123456789101112131415161718public class IBox extends AbstractBox { @Override public String getShape() { return &quot;I&quot;; }}public class LBox extends AbstractBox { @Override public String getShape() { return &quot;L&quot;; }}public class OBox extends AbstractBox { @Override public String getShape() { return &quot;O&quot;; }} 享元工厂（Flyweight Factory）角色 123456789101112131415161718192021public class BoxFactory { private static HashMap&lt;String, AbstractBox&gt; map; private BoxFactory() { map = new HashMap&lt;String, AbstractBox&gt;(); AbstractBox iBox = new IBox(); AbstractBox lBox = new LBox(); AbstractBox oBox = new OBox(); map.put(&quot;I&quot;, iBox); map.put(&quot;L&quot;, lBox); map.put(&quot;O&quot;, oBox); } public static final BoxFactory getInstance() { return SingletonHolder.INSTANCE; } private static class SingletonHolder { private static final BoxFactory INSTANCE = new BoxFactory(); } public AbstractBox getBox(String key) { return map.get(key); }} 【缺点】：为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂【使用场景】：在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。【 JDK源码】： Integer 默认先创建并缓存 -128 ~ 127 之间数的 Integer 对象，当调用 valueOf 时如果参数在 -128 ~ 127 之间则计算下标并从缓存中返回，否则创建一个新的 Integer 对象。","link":"/2021/08/07/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"行为型设计模式总结","text":"行为型设计模式总结 行为型设计模式 1、模板方法模式 2、策略模式 3、命令模式 4、责任链模式 5、状态模式 6、观察者模式 7、中介者模式 8、迭代器模式 9、访问者模式 10、备忘录模式 11、解释器模式 行为型设计模式1、模板方法模式【案例】：1、去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等 2、炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。【概述】：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。【结构】：抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。【实现】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public abstract class AbstractClass { public final void cookProcess() { //第一步：倒油 this.pourOil(); //第二步：热油 this.heatOil(); //第三步：倒蔬菜 this.pourVegetable(); //第四步：倒调味料 this.pourSauce(); //第五步：翻炒 this.fry(); } public void pourOil() { System.out.println(&quot;倒油&quot;); } //第二步：热油是一样的，所以直接实现 public void heatOil() { System.out.println(&quot;热油&quot;); } //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心） public abstract void pourVegetable(); //第四步：倒调味料是不一样 public abstract void pourSauce(); //第五步：翻炒是一样的，所以直接实现 public void fry(){ System.out.println(&quot;炒啊炒啊炒到熟啊&quot;); }}public class ConcreteClass_BaoCai extends AbstractClass { @Override public void pourVegetable() { System.out.println(&quot;下锅的蔬菜是包菜&quot;); } @Override public void pourSauce() { System.out.println(&quot;下锅的酱料是辣椒&quot;); }}public class ConcreteClass_CaiXin extends AbstractClass { @Override public void pourVegetable() { System.out.println(&quot;下锅的蔬菜是菜心&quot;); } @Override public void pourSauce() { System.out.println(&quot;下锅的酱料是蒜蓉&quot;); }}public class Client { public static void main(String[] args) { //炒手撕包菜 ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai(); baoCai.cookProcess(); //炒蒜蓉菜心 ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin(); caiXin.cookProcess(); }} 注：防止恶意操作，一般模板方法都加上 final 关键词。【应用场景】：1、算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。 2、需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。【 JDK源码】：InputStream类就使用了模板方法模式。在InputStream类中定义了多个 read() 方法。在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据，由子类实现。 2、策略模式【案例】：促销活动。一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。【应用场景】：一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。【概述】：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。【结构】：抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。 环境（Context）类：持有一个策略类的引用，最终给客户端调用。【缺点】：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。【实现】： 123public interface Strategy { void show();} 123456789101112131415161718//为春节准备的促销活动Apublic class StrategyA implements Strategy { public void show() { System.out.println(&quot;买一送一&quot;); }}//为中秋准备的促销活动Bpublic class StrategyB implements Strategy { public void show() { System.out.println(&quot;满200元减50元&quot;); }}//为圣诞准备的促销活动Cpublic class StrategyC implements Strategy { public void show() { System.out.println(&quot;满1000元加一元换购任意200元以下商品&quot;); }} 1234567891011public class SalesMan { //持有抽象策略角色的引用 private Strategy strategy; public SalesMan(Strategy strategy) { this.strategy = strategy; } //向客户展示促销活动 public void salesManShow(){ strategy.show(); } } 【JDK源码】：Comparator 中的策略模式。在Arrays类中的 sort() 方法 3、命令模式【案例】：订单、服务员、厨师【概述】：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。【结构】：抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。 具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。【缺点】：使用命令模式可能会导致某些系统有过多的具体命令类，系统结构更加复杂。【应用场景】：系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。在不同的时间指定请求、将请求排队和执行请求。需要支持命令的撤销(Undo)操作和恢复(Redo)操作。【实现】： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public interface Command { void execute();//只需要定义一个统一的执行方法}public class OrderCommand implements Command { //持有接受者对象 private SeniorChef receiver; private Order order; public OrderCommand(SeniorChef receiver, Order order){ this.receiver = receiver; this.order = order; } public void execute() { System.out.println(order.getDiningTable() + &quot;桌的订单：&quot;); Set&lt;String&gt; keys = order.getFoodDic().keySet(); for (String key : keys) { receiver.makeFood(order.getFoodDic().get(key),key); } try { Thread.sleep(100);//停顿一下 模拟做饭的过程 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(order.getDiningTable() + &quot;桌的饭弄好了&quot;); }}public class Order { // 餐桌号码 private int diningTable; // 用来存储餐名并记录份数 private Map&lt;String, Integer&gt; foodDic = new HashMap&lt;String, Integer&gt;(); public int getDiningTable() { return diningTable; } public void setDiningTable(int diningTable) { this.diningTable = diningTable; } public Map&lt;String, Integer&gt; getFoodDic() { return foodDic; } public void setFoodDic(String name, int num) { foodDic.put(name,num); }}// 资深大厨类 是命令的Receiverpublic class SeniorChef { public void makeFood(int num,String foodName) { System.out.println(num + &quot;份&quot; + foodName); }}//服务员public class Waitor { private ArrayList&lt;Command&gt; commands;//可以持有很多的命令对象 public Waitor() { commands = new ArrayList(); } public void setCommand(Command cmd){ commands.add(cmd); } // 发出命令 喊 订单来了，厨师开始执行 public void orderUp() { System.out.println(&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;); for (int i = 0; i &lt; commands.size(); i++) { Command cmd = commands.get(i); if (cmd != null) { cmd.execute(); } } }}public class Client { public static void main(String[] args) { //创建2个order Order order1 = new Order(); order1.setDiningTable(1); order1.getFoodDic().put(&quot;西红柿鸡蛋面&quot;,1); order1.getFoodDic().put(&quot;小杯可乐&quot;,2); Order order2 = new Order(); order2.setDiningTable(3); order2.getFoodDic().put(&quot;尖椒肉丝盖饭&quot;,1); order2.getFoodDic().put(&quot;小杯雪碧&quot;,1); //创建接收者 SeniorChef receiver=new SeniorChef(); //将订单和接收者封装成命令对象 OrderCommand cmd1 = new OrderCommand(receiver, order1); OrderCommand cmd2 = new OrderCommand(receiver, order2); //创建调用者 waitor Waitor invoker = new Waitor(); invoker.setCommand(cmd1); invoker.setCommand(cmd2); //将订单带到柜台 并向厨师喊 订单来了 invoker.orderUp(); }} 【JDK源码】：Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法。会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。 4、责任链模式【案例】：公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名。【概述】：又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。【结构】：抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。【实现】： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//请假条public class LeaveRequest { private String name;//姓名 private int num;//请假天数 private String content;//请假内容 public LeaveRequest(String name, int num, String content) { this.name = name; this.num = num; this.content = content; } public String getName() { return name; } public int getNum() { return num; } public String getContent() { return content; }}//处理者抽象类public abstract class Handler { protected final static int NUM_ONE = 1; protected final static int NUM_THREE = 3; protected final static int NUM_SEVEN = 7; //该领导处理的请假天数区间 private int numStart; private int numEnd; //领导上面还有领导 private Handler nextHandler; //设置请假天数范围 上不封顶 public Handler(int numStart) { this.numStart = numStart; } //设置请假天数范围 public Handler(int numStart, int numEnd) { this.numStart = numStart; this.numEnd = numEnd; } //设置上级领导 public void setNextHandler(Handler nextHandler){ this.nextHandler = nextHandler; } //提交请假条 public final void submit(LeaveRequest leave){ if(0 == this.numStart){ return; } //如果请假天数达到该领导者的处理要求 if(leave.getNum() &gt;= this.numStart){ this.handleLeave(leave); //如果还有上级 并且请假天数超过了当前领导的处理范围 if(null != this.nextHandler &amp;&amp; leave.getNum() &gt; numEnd){ this.nextHandler.submit(leave);//继续提交 } else { System.out.println(&quot;流程结束&quot;); } } } //各级领导处理请假条方法 protected abstract void handleLeave(LeaveRequest leave);}//小组长public class GroupLeader extends Handler { public GroupLeader() { //小组长处理1-3天的请假 super(Handler.NUM_ONE, Handler.NUM_THREE); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;小组长审批：同意。&quot;); }}//部门经理public class Manager extends Handler { public Manager() { //部门经理处理3-7天的请假 super(Handler.NUM_THREE, Handler.NUM_SEVEN); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;部门经理审批：同意。&quot;); }}//总经理public class GeneralManager extends Handler { public GeneralManager() { //部门经理处理7天以上的请假 super(Handler.NUM_SEVEN); } @Override protected void handleLeave(LeaveRequest leave) { System.out.println(leave.getName() + &quot;请假&quot; + leave.getNum() + &quot;天,&quot; + leave.getContent() + &quot;。&quot;); System.out.println(&quot;总经理审批：同意。&quot;); }}//测试类public class Client { public static void main(String[] args) { //请假条来一张 LeaveRequest leave = new LeaveRequest(&quot;小花&quot;,5,&quot;身体不适&quot;); //各位领导 GroupLeader groupLeader = new GroupLeader(); Manager manager = new Manager(); GeneralManager generalManager = new GeneralManager(); groupLeader.setNextHandler(manager);//小组长的领导是部门经理 manager.setNextHandler(generalManager);//部门经理的领导是总经理 //之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。 //提交申请 groupLeader.submit(leave); }} 【JDK源码】：在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用。 5、状态模式【概述】：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。【结构】： 环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。 具体状态（Concrete State）角色：实现抽象状态所对应的行为。【使用场景】：当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。 6、观察者模式【案例】：公众号订阅【概述】：又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。【使用场景】：对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。【结构】：Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。 Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。 ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。【缺点】：如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时 如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃【实现】： 123public interface Observer { void update(String message);} 123456789101112public class WeixinUser implements Observer { // 微信用户名 private String name; public WeixinUser(String name) { this.name = name; } @Override public void update(String message) { System.out.println(name + &quot;-&quot; + message); }} 123456789public interface Subject { //增加订阅者 public void attach(Observer observer); //删除订阅者 public void detach(Observer observer); //通知订阅者更新消息 public void notify(String message);} 123456789101112131415161718public class SubscriptionSubject implements Subject { //储存订阅公众号的微信用户 private List&lt;Observer&gt; weixinUserlist = new ArrayList&lt;Observer&gt;(); @Override public void attach(Observer observer) { weixinUserlist.add(observer); } @Override public void detach(Observer observer) { weixinUserlist.remove(observer); } @Override public void notify(String message) { for (Observer observer : weixinUserlist) { observer.update(message); } }} 123456789101112131415public class Client { public static void main(String[] args) { SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject(); //创建微信用户 WeixinUser user1=new WeixinUser(&quot;孙悟空&quot;); WeixinUser user2=new WeixinUser(&quot;猪悟能&quot;); WeixinUser user3=new WeixinUser(&quot;沙悟净&quot;); //订阅公众号 mSubscriptionSubject.attach(user1); mSubscriptionSubject.attach(user2); mSubscriptionSubject.attach(user3); //公众号更新发出消息给订阅的微信用户 mSubscriptionSubject.notify(&quot;XXXX内容更新了&quot;); }} 7、中介者模式【概述】：又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。【实现】： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//抽象中介者public abstract class Mediator { //申明一个联络方法 public abstract void constact(String message,Person person);}//抽象同事类public abstract class Person { protected String name; protected Mediator mediator; public Person(String name,Mediator mediator){ this.name = name; this.mediator = mediator; }}//具体同事类 房屋拥有者public class HouseOwner extends Person { public HouseOwner(String name, Mediator mediator) { super(name, mediator); } //与中介者联系 public void constact(String message){ mediator.constact(message, this); } //获取信息 public void getMessage(String message){ System.out.println(&quot;房主&quot; + name +&quot;获取到的信息：&quot; + message); }}//具体同事类 承租人public class Tenant extends Person { public Tenant(String name, Mediator mediator) { super(name, mediator); } //与中介者联系 public void constact(String message){ mediator.constact(message, this); } //获取信息 public void getMessage(String message){ System.out.println(&quot;租房者&quot; + name +&quot;获取到的信息：&quot; + message); }}//中介机构public class MediatorStructure extends Mediator { //首先中介结构必须知道所有房主和租房者的信息 private HouseOwner houseOwner; private Tenant tenant; public HouseOwner getHouseOwner() { return houseOwner; } public void setHouseOwner(HouseOwner houseOwner) { this.houseOwner = houseOwner; } public Tenant getTenant() { return tenant; } public void setTenant(Tenant tenant) { this.tenant = tenant; } public void constact(String message, Person person) { if (person == houseOwner) { //如果是房主，则租房者获得信息 tenant.getMessage(message); } else { //反正则是房主获得信息 houseOwner.getMessage(message); } }}//测试类public class Client { public static void main(String[] args) { //一个房主、一个租房者、一个中介机构 MediatorStructure mediator = new MediatorStructure(); //房主和租房者只需要知道中介机构即可 HouseOwner houseOwner = new HouseOwner(&quot;张三&quot;, mediator); Tenant tenant = new Tenant(&quot;李四&quot;, mediator); //中介结构要知道房主和租房者 mediator.setHouseOwner(houseOwner); mediator.setTenant(tenant); tenant.constact(&quot;需要租三室的房子&quot;); houseOwner.constact(&quot;我这有三室的房子，你需要租吗？&quot;); }} 8、迭代器模式【概述】：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。【结构】：抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。【实现】： 1234public interface StudentIterator { boolean hasNext(); Student next();} 1234567891011121314151617public class StudentIteratorImpl implements StudentIterator { private List&lt;Student&gt; list; private int position = 0; public StudentIteratorImpl(List&lt;Student&gt; list) { this.list = list; } @Override public boolean hasNext() { return position &lt; list.size(); } @Override public Student next() { Student currentStudent = list.get(position); position ++; return currentStudent; }} 12345public interface StudentAggregate { void addStudent(Student student); void removeStudent(Student student); StudentIterator getStudentIterator();} 123456789101112131415public class StudentAggregateImpl implements StudentAggregate { private List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); // 学生列表 @Override public void addStudent(Student student) { this.list.add(student); } @Override public void removeStudent(Student student) { this.list.remove(student); } @Override public StudentIterator getStudentIterator() { return new StudentIteratorImpl(list); }} 【JDK源码】：ArrayList 9、访问者模式【案例】：给宠物喂食【概述】：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。【结构】：抽象访问者（Visitor）角色：定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。 抽象元素（Element）角色：定义了一个接受访问者的方法（accept），其意义是指，每一个元素都要可以被访问者访问。 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（Element），并且可以迭代这些元素，供访问者访问。【实现】：创建抽象访问者接口 1234public interface Person { void feed(Cat cat); void feed(Dog dog);} 创建不同的具体访问者角色（主人和其他人），都需要实现 Person接口 1234567891011121314151617181920public class Owner implements Person { @Override public void feed(Cat cat) { System.out.println(&quot;主人喂食猫&quot;); } @Override public void feed(Dog dog) { System.out.println(&quot;主人喂食狗&quot;); }}public class Someone implements Person { @Override public void feed(Cat cat) { System.out.println(&quot;其他人喂食猫&quot;); } @Override public void feed(Dog dog) { System.out.println(&quot;其他人喂食狗&quot;); }} 定义抽象节点 – 宠物 123public interface Animal { void accept(Person person);} 定义实现Animal接口的 具体节点（元素） 1234567891011121314public class Dog implements Animal { @Override public void accept(Person person) { person.feed(this); System.out.println(&quot;好好吃，汪汪汪！！！&quot;); }}public class Cat implements Animal { @Override public void accept(Person person) { person.feed(this); System.out.println(&quot;好好吃，喵喵喵！！！&quot;); }} 12345678910111213public class Home { private List&lt;Animal&gt; nodeList = new ArrayList&lt;Animal&gt;(); public void action(Person person) { for (Animal node : nodeList) { node.accept(person); } } //添加操作 public void add(Animal animal) { nodeList.add(animal); }} 1234567891011public class Client { public static void main(String[] args) { Home home = new Home(); home.add(new Dog()); home.add(new Cat()); Owner owner = new Owner(); home.action(owner); Someone someone = new Someone(); home.action(someone); }} 10、备忘录模式【案例】：游戏挑战BOSS【概述】：又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。【结构】：发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。备忘录有两个等效的接口：窄接口：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。 11、解释器模式【案例】：加减法软件【概述】：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和±符号组成的合法序列，“1+3-2” 就是这种语言的句子。【结构】：抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。","link":"/2021/08/07/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"},{"title":"数据库分库分表","text":"数据库分库分表 1、数据库分表的基本介绍 1.1 为什么分库分表 1.2 数据库 库表的拆分方式 2、两种技术模式的基本介绍 2.1 分库分表的技术模式 2.1 Sharding-JDBC 2.2 MyCat 3、数据库表结构的自动生成 3.1为什么要使用数据表自动生成 3.2 Freemarker的基本使用 3.3 表结构自动生成步骤 1、数据库分表的基本介绍1.1 为什么分库分表一般mysql单表存储数据量小于1千万左右的时候，它的读写性能是最好的。但是当业务发展到一定程度，数据增长到一定程度的时候，我们就会发现为什么查询速度越来越慢了，甚至还会出现数据库挂了等其他一系列问题。此时我们就需要采取一些方案来解决这些问题，一般如下三种：1、分库分表2、读写分离3、利用NoSql 1.2 数据库 库表的拆分方式数据库拆分方式有两种：垂直拆分和水平拆分1）垂直拆分垂直拆分的核心理念是专库专用。拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库。 #mermaid-svg-s56ijih48UGIAIvv .label{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);fill:#333;color:#333}#mermaid-svg-s56ijih48UGIAIvv .label text{fill:#333}#mermaid-svg-s56ijih48UGIAIvv .node rect,#mermaid-svg-s56ijih48UGIAIvv .node circle,#mermaid-svg-s56ijih48UGIAIvv .node ellipse,#mermaid-svg-s56ijih48UGIAIvv .node polygon,#mermaid-svg-s56ijih48UGIAIvv .node path{fill:#ECECFF;stroke:#9370db;stroke-width:1px}#mermaid-svg-s56ijih48UGIAIvv .node .label{text-align:center;fill:#333}#mermaid-svg-s56ijih48UGIAIvv .node.clickable{cursor:pointer}#mermaid-svg-s56ijih48UGIAIvv .arrowheadPath{fill:#333}#mermaid-svg-s56ijih48UGIAIvv .edgePath .path{stroke:#333;stroke-width:1.5px}#mermaid-svg-s56ijih48UGIAIvv .flowchart-link{stroke:#333;fill:none}#mermaid-svg-s56ijih48UGIAIvv .edgeLabel{background-color:#e8e8e8;text-align:center}#mermaid-svg-s56ijih48UGIAIvv .edgeLabel rect{opacity:0.9}#mermaid-svg-s56ijih48UGIAIvv .edgeLabel span{color:#333}#mermaid-svg-s56ijih48UGIAIvv .cluster rect{fill:#ffffde;stroke:#aa3;stroke-width:1px}#mermaid-svg-s56ijih48UGIAIvv .cluster text{fill:#333}#mermaid-svg-s56ijih48UGIAIvv div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}#mermaid-svg-s56ijih48UGIAIvv .actor{stroke:#ccf;fill:#ECECFF}#mermaid-svg-s56ijih48UGIAIvv text.actor>tspan{fill:#000;stroke:none}#mermaid-svg-s56ijih48UGIAIvv .actor-line{stroke:grey}#mermaid-svg-s56ijih48UGIAIvv .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333}#mermaid-svg-s56ijih48UGIAIvv .messageLine1{stroke-width:1.5;stroke-dasharray:2, 2;stroke:#333}#mermaid-svg-s56ijih48UGIAIvv #arrowhead path{fill:#333;stroke:#333}#mermaid-svg-s56ijih48UGIAIvv .sequenceNumber{fill:#fff}#mermaid-svg-s56ijih48UGIAIvv #sequencenumber{fill:#333}#mermaid-svg-s56ijih48UGIAIvv #crosshead path{fill:#333;stroke:#333}#mermaid-svg-s56ijih48UGIAIvv .messageText{fill:#333;stroke:#333}#mermaid-svg-s56ijih48UGIAIvv .labelBox{stroke:#ccf;fill:#ECECFF}#mermaid-svg-s56ijih48UGIAIvv .labelText,#mermaid-svg-s56ijih48UGIAIvv .labelText>tspan{fill:#000;stroke:none}#mermaid-svg-s56ijih48UGIAIvv .loopText,#mermaid-svg-s56ijih48UGIAIvv .loopText>tspan{fill:#000;stroke:none}#mermaid-svg-s56ijih48UGIAIvv .loopLine{stroke-width:2px;stroke-dasharray:2, 2;stroke:#ccf;fill:#ccf}#mermaid-svg-s56ijih48UGIAIvv .note{stroke:#aa3;fill:#fff5ad}#mermaid-svg-s56ijih48UGIAIvv .noteText,#mermaid-svg-s56ijih48UGIAIvv .noteText>tspan{fill:#000;stroke:none}#mermaid-svg-s56ijih48UGIAIvv .activation0{fill:#f4f4f4;stroke:#666}#mermaid-svg-s56ijih48UGIAIvv .activation1{fill:#f4f4f4;stroke:#666}#mermaid-svg-s56ijih48UGIAIvv .activation2{fill:#f4f4f4;stroke:#666}#mermaid-svg-s56ijih48UGIAIvv .mermaid-main-font{font-family:\"trebuchet ms\", verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv .section{stroke:none;opacity:0.2}#mermaid-svg-s56ijih48UGIAIvv .section0{fill:rgba(102,102,255,0.49)}#mermaid-svg-s56ijih48UGIAIvv .section2{fill:#fff400}#mermaid-svg-s56ijih48UGIAIvv .section1,#mermaid-svg-s56ijih48UGIAIvv .section3{fill:#fff;opacity:0.2}#mermaid-svg-s56ijih48UGIAIvv .sectionTitle0{fill:#333}#mermaid-svg-s56ijih48UGIAIvv .sectionTitle1{fill:#333}#mermaid-svg-s56ijih48UGIAIvv .sectionTitle2{fill:#333}#mermaid-svg-s56ijih48UGIAIvv .sectionTitle3{fill:#333}#mermaid-svg-s56ijih48UGIAIvv .sectionTitle{text-anchor:start;font-size:11px;text-height:14px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv .grid .tick{stroke:#d3d3d3;opacity:0.8;shape-rendering:crispEdges}#mermaid-svg-s56ijih48UGIAIvv .grid .tick text{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv .grid path{stroke-width:0}#mermaid-svg-s56ijih48UGIAIvv .today{fill:none;stroke:red;stroke-width:2px}#mermaid-svg-s56ijih48UGIAIvv .task{stroke-width:2}#mermaid-svg-s56ijih48UGIAIvv .taskText{text-anchor:middle;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv .taskText:not([font-size]){font-size:11px}#mermaid-svg-s56ijih48UGIAIvv .taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv .taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}#mermaid-svg-s56ijih48UGIAIvv .task.clickable{cursor:pointer}#mermaid-svg-s56ijih48UGIAIvv .taskText.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-s56ijih48UGIAIvv .taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-s56ijih48UGIAIvv .taskTextOutsideRight.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-s56ijih48UGIAIvv .taskText0,#mermaid-svg-s56ijih48UGIAIvv .taskText1,#mermaid-svg-s56ijih48UGIAIvv .taskText2,#mermaid-svg-s56ijih48UGIAIvv .taskText3{fill:#fff}#mermaid-svg-s56ijih48UGIAIvv .task0,#mermaid-svg-s56ijih48UGIAIvv .task1,#mermaid-svg-s56ijih48UGIAIvv .task2,#mermaid-svg-s56ijih48UGIAIvv .task3{fill:#8a90dd;stroke:#534fbc}#mermaid-svg-s56ijih48UGIAIvv .taskTextOutside0,#mermaid-svg-s56ijih48UGIAIvv .taskTextOutside2{fill:#000}#mermaid-svg-s56ijih48UGIAIvv .taskTextOutside1,#mermaid-svg-s56ijih48UGIAIvv .taskTextOutside3{fill:#000}#mermaid-svg-s56ijih48UGIAIvv .active0,#mermaid-svg-s56ijih48UGIAIvv .active1,#mermaid-svg-s56ijih48UGIAIvv .active2,#mermaid-svg-s56ijih48UGIAIvv .active3{fill:#bfc7ff;stroke:#534fbc}#mermaid-svg-s56ijih48UGIAIvv .activeText0,#mermaid-svg-s56ijih48UGIAIvv .activeText1,#mermaid-svg-s56ijih48UGIAIvv .activeText2,#mermaid-svg-s56ijih48UGIAIvv .activeText3{fill:#000 !important}#mermaid-svg-s56ijih48UGIAIvv .done0,#mermaid-svg-s56ijih48UGIAIvv .done1,#mermaid-svg-s56ijih48UGIAIvv .done2,#mermaid-svg-s56ijih48UGIAIvv .done3{stroke:grey;fill:#d3d3d3;stroke-width:2}#mermaid-svg-s56ijih48UGIAIvv .doneText0,#mermaid-svg-s56ijih48UGIAIvv .doneText1,#mermaid-svg-s56ijih48UGIAIvv .doneText2,#mermaid-svg-s56ijih48UGIAIvv .doneText3{fill:#000 !important}#mermaid-svg-s56ijih48UGIAIvv .crit0,#mermaid-svg-s56ijih48UGIAIvv .crit1,#mermaid-svg-s56ijih48UGIAIvv .crit2,#mermaid-svg-s56ijih48UGIAIvv .crit3{stroke:#f88;fill:red;stroke-width:2}#mermaid-svg-s56ijih48UGIAIvv .activeCrit0,#mermaid-svg-s56ijih48UGIAIvv .activeCrit1,#mermaid-svg-s56ijih48UGIAIvv .activeCrit2,#mermaid-svg-s56ijih48UGIAIvv .activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}#mermaid-svg-s56ijih48UGIAIvv .doneCrit0,#mermaid-svg-s56ijih48UGIAIvv .doneCrit1,#mermaid-svg-s56ijih48UGIAIvv .doneCrit2,#mermaid-svg-s56ijih48UGIAIvv .doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}#mermaid-svg-s56ijih48UGIAIvv .milestone{transform:rotate(45deg) scale(0.8, 0.8)}#mermaid-svg-s56ijih48UGIAIvv .milestoneText{font-style:italic}#mermaid-svg-s56ijih48UGIAIvv .doneCritText0,#mermaid-svg-s56ijih48UGIAIvv .doneCritText1,#mermaid-svg-s56ijih48UGIAIvv .doneCritText2,#mermaid-svg-s56ijih48UGIAIvv .doneCritText3{fill:#000 !important}#mermaid-svg-s56ijih48UGIAIvv .activeCritText0,#mermaid-svg-s56ijih48UGIAIvv .activeCritText1,#mermaid-svg-s56ijih48UGIAIvv .activeCritText2,#mermaid-svg-s56ijih48UGIAIvv .activeCritText3{fill:#000 !important}#mermaid-svg-s56ijih48UGIAIvv .titleText{text-anchor:middle;font-size:18px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv g.classGroup text{fill:#9370db;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:10px}#mermaid-svg-s56ijih48UGIAIvv g.classGroup text .title{font-weight:bolder}#mermaid-svg-s56ijih48UGIAIvv g.clickable{cursor:pointer}#mermaid-svg-s56ijih48UGIAIvv g.classGroup rect{fill:#ECECFF;stroke:#9370db}#mermaid-svg-s56ijih48UGIAIvv g.classGroup line{stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5}#mermaid-svg-s56ijih48UGIAIvv .classLabel .label{fill:#9370db;font-size:10px}#mermaid-svg-s56ijih48UGIAIvv .relation{stroke:#9370db;stroke-width:1;fill:none}#mermaid-svg-s56ijih48UGIAIvv .dashed-line{stroke-dasharray:3}#mermaid-svg-s56ijih48UGIAIvv #compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv #compositionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv #aggregationStart{fill:#ECECFF;stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv #aggregationEnd{fill:#ECECFF;stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv #dependencyStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv #dependencyEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv #extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv #extensionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv .commit-id,#mermaid-svg-s56ijih48UGIAIvv .commit-msg,#mermaid-svg-s56ijih48UGIAIvv .branch-label{fill:lightgrey;color:lightgrey;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv .pieTitleText{text-anchor:middle;font-size:25px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv .slice{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv g.stateGroup text{fill:#9370db;stroke:none;font-size:10px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv g.stateGroup text{fill:#9370db;fill:#333;stroke:none;font-size:10px}#mermaid-svg-s56ijih48UGIAIvv g.statediagram-cluster .cluster-label text{fill:#333}#mermaid-svg-s56ijih48UGIAIvv g.stateGroup .state-title{font-weight:bolder;fill:#000}#mermaid-svg-s56ijih48UGIAIvv g.stateGroup rect{fill:#ECECFF;stroke:#9370db}#mermaid-svg-s56ijih48UGIAIvv g.stateGroup line{stroke:#9370db;stroke-width:1}#mermaid-svg-s56ijih48UGIAIvv .transition{stroke:#9370db;stroke-width:1;fill:none}#mermaid-svg-s56ijih48UGIAIvv .stateGroup .composit{fill:white;border-bottom:1px}#mermaid-svg-s56ijih48UGIAIvv .stateGroup .alt-composit{fill:#e0e0e0;border-bottom:1px}#mermaid-svg-s56ijih48UGIAIvv .state-note{stroke:#aa3;fill:#fff5ad}#mermaid-svg-s56ijih48UGIAIvv .state-note text{fill:black;stroke:none;font-size:10px}#mermaid-svg-s56ijih48UGIAIvv .stateLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.7}#mermaid-svg-s56ijih48UGIAIvv .edgeLabel text{fill:#333}#mermaid-svg-s56ijih48UGIAIvv .stateLabel text{fill:#000;font-size:10px;font-weight:bold;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-s56ijih48UGIAIvv .node circle.state-start{fill:black;stroke:black}#mermaid-svg-s56ijih48UGIAIvv .node circle.state-end{fill:black;stroke:white;stroke-width:1.5}#mermaid-svg-s56ijih48UGIAIvv #statediagram-barbEnd{fill:#9370db}#mermaid-svg-s56ijih48UGIAIvv .statediagram-cluster rect{fill:#ECECFF;stroke:#9370db;stroke-width:1px}#mermaid-svg-s56ijih48UGIAIvv .statediagram-cluster rect.outer{rx:5px;ry:5px}#mermaid-svg-s56ijih48UGIAIvv .statediagram-state .divider{stroke:#9370db}#mermaid-svg-s56ijih48UGIAIvv .statediagram-state .title-state{rx:5px;ry:5px}#mermaid-svg-s56ijih48UGIAIvv .statediagram-cluster.statediagram-cluster .inner{fill:white}#mermaid-svg-s56ijih48UGIAIvv .statediagram-cluster.statediagram-cluster-alt .inner{fill:#e0e0e0}#mermaid-svg-s56ijih48UGIAIvv .statediagram-cluster .inner{rx:0;ry:0}#mermaid-svg-s56ijih48UGIAIvv .statediagram-state rect.basic{rx:5px;ry:5px}#mermaid-svg-s56ijih48UGIAIvv .statediagram-state rect.divider{stroke-dasharray:10,10;fill:#efefef}#mermaid-svg-s56ijih48UGIAIvv .note-edge{stroke-dasharray:5}#mermaid-svg-s56ijih48UGIAIvv .statediagram-note rect{fill:#fff5ad;stroke:#aa3;stroke-width:1px;rx:0;ry:0}:root{--mermaid-font-family: '\"trebuchet ms\", verdana, arial';--mermaid-font-family: \"Comic Sans MS\", \"Comic Sans\", cursive}#mermaid-svg-s56ijih48UGIAIvv .error-icon{fill:#522}#mermaid-svg-s56ijih48UGIAIvv .error-text{fill:#522;stroke:#522}#mermaid-svg-s56ijih48UGIAIvv .edge-thickness-normal{stroke-width:2px}#mermaid-svg-s56ijih48UGIAIvv .edge-thickness-thick{stroke-width:3.5px}#mermaid-svg-s56ijih48UGIAIvv .edge-pattern-solid{stroke-dasharray:0}#mermaid-svg-s56ijih48UGIAIvv .edge-pattern-dashed{stroke-dasharray:3}#mermaid-svg-s56ijih48UGIAIvv .edge-pattern-dotted{stroke-dasharray:2}#mermaid-svg-s56ijih48UGIAIvv .marker{fill:#333}#mermaid-svg-s56ijih48UGIAIvv .marker.cross{stroke:#333} :root { --mermaid-font-family: \"trebuchet ms\", verdana, arial;} #mermaid-svg-s56ijih48UGIAIvv { color: rgba(0, 0, 0, 0.75); font: ; } select * from t_usr Database select * from t_order 1由上到下 #mermaid-svg-VDWle3OALy2vNW0o .label{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);fill:#333;color:#333}#mermaid-svg-VDWle3OALy2vNW0o .label text{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .node rect,#mermaid-svg-VDWle3OALy2vNW0o .node circle,#mermaid-svg-VDWle3OALy2vNW0o .node ellipse,#mermaid-svg-VDWle3OALy2vNW0o .node polygon,#mermaid-svg-VDWle3OALy2vNW0o .node path{fill:#ECECFF;stroke:#9370db;stroke-width:1px}#mermaid-svg-VDWle3OALy2vNW0o .node .label{text-align:center;fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .node.clickable{cursor:pointer}#mermaid-svg-VDWle3OALy2vNW0o .arrowheadPath{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .edgePath .path{stroke:#333;stroke-width:1.5px}#mermaid-svg-VDWle3OALy2vNW0o .flowchart-link{stroke:#333;fill:none}#mermaid-svg-VDWle3OALy2vNW0o .edgeLabel{background-color:#e8e8e8;text-align:center}#mermaid-svg-VDWle3OALy2vNW0o .edgeLabel rect{opacity:0.9}#mermaid-svg-VDWle3OALy2vNW0o .edgeLabel span{color:#333}#mermaid-svg-VDWle3OALy2vNW0o .cluster rect{fill:#ffffde;stroke:#aa3;stroke-width:1px}#mermaid-svg-VDWle3OALy2vNW0o .cluster text{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}#mermaid-svg-VDWle3OALy2vNW0o .actor{stroke:#ccf;fill:#ECECFF}#mermaid-svg-VDWle3OALy2vNW0o text.actor>tspan{fill:#000;stroke:none}#mermaid-svg-VDWle3OALy2vNW0o .actor-line{stroke:grey}#mermaid-svg-VDWle3OALy2vNW0o .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333}#mermaid-svg-VDWle3OALy2vNW0o .messageLine1{stroke-width:1.5;stroke-dasharray:2, 2;stroke:#333}#mermaid-svg-VDWle3OALy2vNW0o #arrowhead path{fill:#333;stroke:#333}#mermaid-svg-VDWle3OALy2vNW0o .sequenceNumber{fill:#fff}#mermaid-svg-VDWle3OALy2vNW0o #sequencenumber{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o #crosshead path{fill:#333;stroke:#333}#mermaid-svg-VDWle3OALy2vNW0o .messageText{fill:#333;stroke:#333}#mermaid-svg-VDWle3OALy2vNW0o .labelBox{stroke:#ccf;fill:#ECECFF}#mermaid-svg-VDWle3OALy2vNW0o .labelText,#mermaid-svg-VDWle3OALy2vNW0o .labelText>tspan{fill:#000;stroke:none}#mermaid-svg-VDWle3OALy2vNW0o .loopText,#mermaid-svg-VDWle3OALy2vNW0o .loopText>tspan{fill:#000;stroke:none}#mermaid-svg-VDWle3OALy2vNW0o .loopLine{stroke-width:2px;stroke-dasharray:2, 2;stroke:#ccf;fill:#ccf}#mermaid-svg-VDWle3OALy2vNW0o .note{stroke:#aa3;fill:#fff5ad}#mermaid-svg-VDWle3OALy2vNW0o .noteText,#mermaid-svg-VDWle3OALy2vNW0o .noteText>tspan{fill:#000;stroke:none}#mermaid-svg-VDWle3OALy2vNW0o .activation0{fill:#f4f4f4;stroke:#666}#mermaid-svg-VDWle3OALy2vNW0o .activation1{fill:#f4f4f4;stroke:#666}#mermaid-svg-VDWle3OALy2vNW0o .activation2{fill:#f4f4f4;stroke:#666}#mermaid-svg-VDWle3OALy2vNW0o .mermaid-main-font{font-family:\"trebuchet ms\", verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o .section{stroke:none;opacity:0.2}#mermaid-svg-VDWle3OALy2vNW0o .section0{fill:rgba(102,102,255,0.49)}#mermaid-svg-VDWle3OALy2vNW0o .section2{fill:#fff400}#mermaid-svg-VDWle3OALy2vNW0o .section1,#mermaid-svg-VDWle3OALy2vNW0o .section3{fill:#fff;opacity:0.2}#mermaid-svg-VDWle3OALy2vNW0o .sectionTitle0{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .sectionTitle1{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .sectionTitle2{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .sectionTitle3{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .sectionTitle{text-anchor:start;font-size:11px;text-height:14px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o .grid .tick{stroke:#d3d3d3;opacity:0.8;shape-rendering:crispEdges}#mermaid-svg-VDWle3OALy2vNW0o .grid .tick text{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o .grid path{stroke-width:0}#mermaid-svg-VDWle3OALy2vNW0o .today{fill:none;stroke:red;stroke-width:2px}#mermaid-svg-VDWle3OALy2vNW0o .task{stroke-width:2}#mermaid-svg-VDWle3OALy2vNW0o .taskText{text-anchor:middle;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o .taskText:not([font-size]){font-size:11px}#mermaid-svg-VDWle3OALy2vNW0o .taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o .taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}#mermaid-svg-VDWle3OALy2vNW0o .task.clickable{cursor:pointer}#mermaid-svg-VDWle3OALy2vNW0o .taskText.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-VDWle3OALy2vNW0o .taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-VDWle3OALy2vNW0o .taskTextOutsideRight.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-VDWle3OALy2vNW0o .taskText0,#mermaid-svg-VDWle3OALy2vNW0o .taskText1,#mermaid-svg-VDWle3OALy2vNW0o .taskText2,#mermaid-svg-VDWle3OALy2vNW0o .taskText3{fill:#fff}#mermaid-svg-VDWle3OALy2vNW0o .task0,#mermaid-svg-VDWle3OALy2vNW0o .task1,#mermaid-svg-VDWle3OALy2vNW0o .task2,#mermaid-svg-VDWle3OALy2vNW0o .task3{fill:#8a90dd;stroke:#534fbc}#mermaid-svg-VDWle3OALy2vNW0o .taskTextOutside0,#mermaid-svg-VDWle3OALy2vNW0o .taskTextOutside2{fill:#000}#mermaid-svg-VDWle3OALy2vNW0o .taskTextOutside1,#mermaid-svg-VDWle3OALy2vNW0o .taskTextOutside3{fill:#000}#mermaid-svg-VDWle3OALy2vNW0o .active0,#mermaid-svg-VDWle3OALy2vNW0o .active1,#mermaid-svg-VDWle3OALy2vNW0o .active2,#mermaid-svg-VDWle3OALy2vNW0o .active3{fill:#bfc7ff;stroke:#534fbc}#mermaid-svg-VDWle3OALy2vNW0o .activeText0,#mermaid-svg-VDWle3OALy2vNW0o .activeText1,#mermaid-svg-VDWle3OALy2vNW0o .activeText2,#mermaid-svg-VDWle3OALy2vNW0o .activeText3{fill:#000 !important}#mermaid-svg-VDWle3OALy2vNW0o .done0,#mermaid-svg-VDWle3OALy2vNW0o .done1,#mermaid-svg-VDWle3OALy2vNW0o .done2,#mermaid-svg-VDWle3OALy2vNW0o .done3{stroke:grey;fill:#d3d3d3;stroke-width:2}#mermaid-svg-VDWle3OALy2vNW0o .doneText0,#mermaid-svg-VDWle3OALy2vNW0o .doneText1,#mermaid-svg-VDWle3OALy2vNW0o .doneText2,#mermaid-svg-VDWle3OALy2vNW0o .doneText3{fill:#000 !important}#mermaid-svg-VDWle3OALy2vNW0o .crit0,#mermaid-svg-VDWle3OALy2vNW0o .crit1,#mermaid-svg-VDWle3OALy2vNW0o .crit2,#mermaid-svg-VDWle3OALy2vNW0o .crit3{stroke:#f88;fill:red;stroke-width:2}#mermaid-svg-VDWle3OALy2vNW0o .activeCrit0,#mermaid-svg-VDWle3OALy2vNW0o .activeCrit1,#mermaid-svg-VDWle3OALy2vNW0o .activeCrit2,#mermaid-svg-VDWle3OALy2vNW0o .activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}#mermaid-svg-VDWle3OALy2vNW0o .doneCrit0,#mermaid-svg-VDWle3OALy2vNW0o .doneCrit1,#mermaid-svg-VDWle3OALy2vNW0o .doneCrit2,#mermaid-svg-VDWle3OALy2vNW0o .doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}#mermaid-svg-VDWle3OALy2vNW0o .milestone{transform:rotate(45deg) scale(0.8, 0.8)}#mermaid-svg-VDWle3OALy2vNW0o .milestoneText{font-style:italic}#mermaid-svg-VDWle3OALy2vNW0o .doneCritText0,#mermaid-svg-VDWle3OALy2vNW0o .doneCritText1,#mermaid-svg-VDWle3OALy2vNW0o .doneCritText2,#mermaid-svg-VDWle3OALy2vNW0o .doneCritText3{fill:#000 !important}#mermaid-svg-VDWle3OALy2vNW0o .activeCritText0,#mermaid-svg-VDWle3OALy2vNW0o .activeCritText1,#mermaid-svg-VDWle3OALy2vNW0o .activeCritText2,#mermaid-svg-VDWle3OALy2vNW0o .activeCritText3{fill:#000 !important}#mermaid-svg-VDWle3OALy2vNW0o .titleText{text-anchor:middle;font-size:18px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o g.classGroup text{fill:#9370db;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:10px}#mermaid-svg-VDWle3OALy2vNW0o g.classGroup text .title{font-weight:bolder}#mermaid-svg-VDWle3OALy2vNW0o g.clickable{cursor:pointer}#mermaid-svg-VDWle3OALy2vNW0o g.classGroup rect{fill:#ECECFF;stroke:#9370db}#mermaid-svg-VDWle3OALy2vNW0o g.classGroup line{stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5}#mermaid-svg-VDWle3OALy2vNW0o .classLabel .label{fill:#9370db;font-size:10px}#mermaid-svg-VDWle3OALy2vNW0o .relation{stroke:#9370db;stroke-width:1;fill:none}#mermaid-svg-VDWle3OALy2vNW0o .dashed-line{stroke-dasharray:3}#mermaid-svg-VDWle3OALy2vNW0o #compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o #compositionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o #aggregationStart{fill:#ECECFF;stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o #aggregationEnd{fill:#ECECFF;stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o #dependencyStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o #dependencyEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o #extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o #extensionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o .commit-id,#mermaid-svg-VDWle3OALy2vNW0o .commit-msg,#mermaid-svg-VDWle3OALy2vNW0o .branch-label{fill:lightgrey;color:lightgrey;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o .pieTitleText{text-anchor:middle;font-size:25px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o .slice{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o g.stateGroup text{fill:#9370db;stroke:none;font-size:10px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o g.stateGroup text{fill:#9370db;fill:#333;stroke:none;font-size:10px}#mermaid-svg-VDWle3OALy2vNW0o g.statediagram-cluster .cluster-label text{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o g.stateGroup .state-title{font-weight:bolder;fill:#000}#mermaid-svg-VDWle3OALy2vNW0o g.stateGroup rect{fill:#ECECFF;stroke:#9370db}#mermaid-svg-VDWle3OALy2vNW0o g.stateGroup line{stroke:#9370db;stroke-width:1}#mermaid-svg-VDWle3OALy2vNW0o .transition{stroke:#9370db;stroke-width:1;fill:none}#mermaid-svg-VDWle3OALy2vNW0o .stateGroup .composit{fill:white;border-bottom:1px}#mermaid-svg-VDWle3OALy2vNW0o .stateGroup .alt-composit{fill:#e0e0e0;border-bottom:1px}#mermaid-svg-VDWle3OALy2vNW0o .state-note{stroke:#aa3;fill:#fff5ad}#mermaid-svg-VDWle3OALy2vNW0o .state-note text{fill:black;stroke:none;font-size:10px}#mermaid-svg-VDWle3OALy2vNW0o .stateLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.7}#mermaid-svg-VDWle3OALy2vNW0o .edgeLabel text{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .stateLabel text{fill:#000;font-size:10px;font-weight:bold;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-VDWle3OALy2vNW0o .node circle.state-start{fill:black;stroke:black}#mermaid-svg-VDWle3OALy2vNW0o .node circle.state-end{fill:black;stroke:white;stroke-width:1.5}#mermaid-svg-VDWle3OALy2vNW0o #statediagram-barbEnd{fill:#9370db}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-cluster rect{fill:#ECECFF;stroke:#9370db;stroke-width:1px}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-cluster rect.outer{rx:5px;ry:5px}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-state .divider{stroke:#9370db}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-state .title-state{rx:5px;ry:5px}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-cluster.statediagram-cluster .inner{fill:white}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-cluster.statediagram-cluster-alt .inner{fill:#e0e0e0}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-cluster .inner{rx:0;ry:0}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-state rect.basic{rx:5px;ry:5px}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-state rect.divider{stroke-dasharray:10,10;fill:#efefef}#mermaid-svg-VDWle3OALy2vNW0o .note-edge{stroke-dasharray:5}#mermaid-svg-VDWle3OALy2vNW0o .statediagram-note rect{fill:#fff5ad;stroke:#aa3;stroke-width:1px;rx:0;ry:0}:root{--mermaid-font-family: '\"trebuchet ms\", verdana, arial';--mermaid-font-family: \"Comic Sans MS\", \"Comic Sans\", cursive}#mermaid-svg-VDWle3OALy2vNW0o .error-icon{fill:#522}#mermaid-svg-VDWle3OALy2vNW0o .error-text{fill:#522;stroke:#522}#mermaid-svg-VDWle3OALy2vNW0o .edge-thickness-normal{stroke-width:2px}#mermaid-svg-VDWle3OALy2vNW0o .edge-thickness-thick{stroke-width:3.5px}#mermaid-svg-VDWle3OALy2vNW0o .edge-pattern-solid{stroke-dasharray:0}#mermaid-svg-VDWle3OALy2vNW0o .edge-pattern-dashed{stroke-dasharray:3}#mermaid-svg-VDWle3OALy2vNW0o .edge-pattern-dotted{stroke-dasharray:2}#mermaid-svg-VDWle3OALy2vNW0o .marker{fill:#333}#mermaid-svg-VDWle3OALy2vNW0o .marker.cross{stroke:#333} :root { --mermaid-font-family: \"trebuchet ms\", verdana, arial;} #mermaid-svg-VDWle3OALy2vNW0o { color: rgba(0, 0, 0, 0.75); font: ; } select * from t_usr Database01 select * from t_order Database02 2）水平拆分它不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 #mermaid-svg-ofyXPQUemxGFJKMq .label{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);fill:#333;color:#333}#mermaid-svg-ofyXPQUemxGFJKMq .label text{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .node rect,#mermaid-svg-ofyXPQUemxGFJKMq .node circle,#mermaid-svg-ofyXPQUemxGFJKMq .node ellipse,#mermaid-svg-ofyXPQUemxGFJKMq .node polygon,#mermaid-svg-ofyXPQUemxGFJKMq .node path{fill:#ECECFF;stroke:#9370db;stroke-width:1px}#mermaid-svg-ofyXPQUemxGFJKMq .node .label{text-align:center;fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .node.clickable{cursor:pointer}#mermaid-svg-ofyXPQUemxGFJKMq .arrowheadPath{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .edgePath .path{stroke:#333;stroke-width:1.5px}#mermaid-svg-ofyXPQUemxGFJKMq .flowchart-link{stroke:#333;fill:none}#mermaid-svg-ofyXPQUemxGFJKMq .edgeLabel{background-color:#e8e8e8;text-align:center}#mermaid-svg-ofyXPQUemxGFJKMq .edgeLabel rect{opacity:0.9}#mermaid-svg-ofyXPQUemxGFJKMq .edgeLabel span{color:#333}#mermaid-svg-ofyXPQUemxGFJKMq .cluster rect{fill:#ffffde;stroke:#aa3;stroke-width:1px}#mermaid-svg-ofyXPQUemxGFJKMq .cluster text{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}#mermaid-svg-ofyXPQUemxGFJKMq .actor{stroke:#ccf;fill:#ECECFF}#mermaid-svg-ofyXPQUemxGFJKMq text.actor>tspan{fill:#000;stroke:none}#mermaid-svg-ofyXPQUemxGFJKMq .actor-line{stroke:grey}#mermaid-svg-ofyXPQUemxGFJKMq .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333}#mermaid-svg-ofyXPQUemxGFJKMq .messageLine1{stroke-width:1.5;stroke-dasharray:2, 2;stroke:#333}#mermaid-svg-ofyXPQUemxGFJKMq #arrowhead path{fill:#333;stroke:#333}#mermaid-svg-ofyXPQUemxGFJKMq .sequenceNumber{fill:#fff}#mermaid-svg-ofyXPQUemxGFJKMq #sequencenumber{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq #crosshead path{fill:#333;stroke:#333}#mermaid-svg-ofyXPQUemxGFJKMq .messageText{fill:#333;stroke:#333}#mermaid-svg-ofyXPQUemxGFJKMq .labelBox{stroke:#ccf;fill:#ECECFF}#mermaid-svg-ofyXPQUemxGFJKMq .labelText,#mermaid-svg-ofyXPQUemxGFJKMq .labelText>tspan{fill:#000;stroke:none}#mermaid-svg-ofyXPQUemxGFJKMq .loopText,#mermaid-svg-ofyXPQUemxGFJKMq .loopText>tspan{fill:#000;stroke:none}#mermaid-svg-ofyXPQUemxGFJKMq .loopLine{stroke-width:2px;stroke-dasharray:2, 2;stroke:#ccf;fill:#ccf}#mermaid-svg-ofyXPQUemxGFJKMq .note{stroke:#aa3;fill:#fff5ad}#mermaid-svg-ofyXPQUemxGFJKMq .noteText,#mermaid-svg-ofyXPQUemxGFJKMq .noteText>tspan{fill:#000;stroke:none}#mermaid-svg-ofyXPQUemxGFJKMq .activation0{fill:#f4f4f4;stroke:#666}#mermaid-svg-ofyXPQUemxGFJKMq .activation1{fill:#f4f4f4;stroke:#666}#mermaid-svg-ofyXPQUemxGFJKMq .activation2{fill:#f4f4f4;stroke:#666}#mermaid-svg-ofyXPQUemxGFJKMq .mermaid-main-font{font-family:\"trebuchet ms\", verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq .section{stroke:none;opacity:0.2}#mermaid-svg-ofyXPQUemxGFJKMq .section0{fill:rgba(102,102,255,0.49)}#mermaid-svg-ofyXPQUemxGFJKMq .section2{fill:#fff400}#mermaid-svg-ofyXPQUemxGFJKMq .section1,#mermaid-svg-ofyXPQUemxGFJKMq .section3{fill:#fff;opacity:0.2}#mermaid-svg-ofyXPQUemxGFJKMq .sectionTitle0{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .sectionTitle1{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .sectionTitle2{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .sectionTitle3{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .sectionTitle{text-anchor:start;font-size:11px;text-height:14px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq .grid .tick{stroke:#d3d3d3;opacity:0.8;shape-rendering:crispEdges}#mermaid-svg-ofyXPQUemxGFJKMq .grid .tick text{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq .grid path{stroke-width:0}#mermaid-svg-ofyXPQUemxGFJKMq .today{fill:none;stroke:red;stroke-width:2px}#mermaid-svg-ofyXPQUemxGFJKMq .task{stroke-width:2}#mermaid-svg-ofyXPQUemxGFJKMq .taskText{text-anchor:middle;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq .taskText:not([font-size]){font-size:11px}#mermaid-svg-ofyXPQUemxGFJKMq .taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq .taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}#mermaid-svg-ofyXPQUemxGFJKMq .task.clickable{cursor:pointer}#mermaid-svg-ofyXPQUemxGFJKMq .taskText.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-ofyXPQUemxGFJKMq .taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-ofyXPQUemxGFJKMq .taskTextOutsideRight.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-ofyXPQUemxGFJKMq .taskText0,#mermaid-svg-ofyXPQUemxGFJKMq .taskText1,#mermaid-svg-ofyXPQUemxGFJKMq .taskText2,#mermaid-svg-ofyXPQUemxGFJKMq .taskText3{fill:#fff}#mermaid-svg-ofyXPQUemxGFJKMq .task0,#mermaid-svg-ofyXPQUemxGFJKMq .task1,#mermaid-svg-ofyXPQUemxGFJKMq .task2,#mermaid-svg-ofyXPQUemxGFJKMq .task3{fill:#8a90dd;stroke:#534fbc}#mermaid-svg-ofyXPQUemxGFJKMq .taskTextOutside0,#mermaid-svg-ofyXPQUemxGFJKMq .taskTextOutside2{fill:#000}#mermaid-svg-ofyXPQUemxGFJKMq .taskTextOutside1,#mermaid-svg-ofyXPQUemxGFJKMq .taskTextOutside3{fill:#000}#mermaid-svg-ofyXPQUemxGFJKMq .active0,#mermaid-svg-ofyXPQUemxGFJKMq .active1,#mermaid-svg-ofyXPQUemxGFJKMq .active2,#mermaid-svg-ofyXPQUemxGFJKMq .active3{fill:#bfc7ff;stroke:#534fbc}#mermaid-svg-ofyXPQUemxGFJKMq .activeText0,#mermaid-svg-ofyXPQUemxGFJKMq .activeText1,#mermaid-svg-ofyXPQUemxGFJKMq .activeText2,#mermaid-svg-ofyXPQUemxGFJKMq .activeText3{fill:#000 !important}#mermaid-svg-ofyXPQUemxGFJKMq .done0,#mermaid-svg-ofyXPQUemxGFJKMq .done1,#mermaid-svg-ofyXPQUemxGFJKMq .done2,#mermaid-svg-ofyXPQUemxGFJKMq .done3{stroke:grey;fill:#d3d3d3;stroke-width:2}#mermaid-svg-ofyXPQUemxGFJKMq .doneText0,#mermaid-svg-ofyXPQUemxGFJKMq .doneText1,#mermaid-svg-ofyXPQUemxGFJKMq .doneText2,#mermaid-svg-ofyXPQUemxGFJKMq .doneText3{fill:#000 !important}#mermaid-svg-ofyXPQUemxGFJKMq .crit0,#mermaid-svg-ofyXPQUemxGFJKMq .crit1,#mermaid-svg-ofyXPQUemxGFJKMq .crit2,#mermaid-svg-ofyXPQUemxGFJKMq .crit3{stroke:#f88;fill:red;stroke-width:2}#mermaid-svg-ofyXPQUemxGFJKMq .activeCrit0,#mermaid-svg-ofyXPQUemxGFJKMq .activeCrit1,#mermaid-svg-ofyXPQUemxGFJKMq .activeCrit2,#mermaid-svg-ofyXPQUemxGFJKMq .activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}#mermaid-svg-ofyXPQUemxGFJKMq .doneCrit0,#mermaid-svg-ofyXPQUemxGFJKMq .doneCrit1,#mermaid-svg-ofyXPQUemxGFJKMq .doneCrit2,#mermaid-svg-ofyXPQUemxGFJKMq .doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}#mermaid-svg-ofyXPQUemxGFJKMq .milestone{transform:rotate(45deg) scale(0.8, 0.8)}#mermaid-svg-ofyXPQUemxGFJKMq .milestoneText{font-style:italic}#mermaid-svg-ofyXPQUemxGFJKMq .doneCritText0,#mermaid-svg-ofyXPQUemxGFJKMq .doneCritText1,#mermaid-svg-ofyXPQUemxGFJKMq .doneCritText2,#mermaid-svg-ofyXPQUemxGFJKMq .doneCritText3{fill:#000 !important}#mermaid-svg-ofyXPQUemxGFJKMq .activeCritText0,#mermaid-svg-ofyXPQUemxGFJKMq .activeCritText1,#mermaid-svg-ofyXPQUemxGFJKMq .activeCritText2,#mermaid-svg-ofyXPQUemxGFJKMq .activeCritText3{fill:#000 !important}#mermaid-svg-ofyXPQUemxGFJKMq .titleText{text-anchor:middle;font-size:18px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq g.classGroup text{fill:#9370db;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:10px}#mermaid-svg-ofyXPQUemxGFJKMq g.classGroup text .title{font-weight:bolder}#mermaid-svg-ofyXPQUemxGFJKMq g.clickable{cursor:pointer}#mermaid-svg-ofyXPQUemxGFJKMq g.classGroup rect{fill:#ECECFF;stroke:#9370db}#mermaid-svg-ofyXPQUemxGFJKMq g.classGroup line{stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5}#mermaid-svg-ofyXPQUemxGFJKMq .classLabel .label{fill:#9370db;font-size:10px}#mermaid-svg-ofyXPQUemxGFJKMq .relation{stroke:#9370db;stroke-width:1;fill:none}#mermaid-svg-ofyXPQUemxGFJKMq .dashed-line{stroke-dasharray:3}#mermaid-svg-ofyXPQUemxGFJKMq #compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq #compositionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq #aggregationStart{fill:#ECECFF;stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq #aggregationEnd{fill:#ECECFF;stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq #dependencyStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq #dependencyEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq #extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq #extensionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq .commit-id,#mermaid-svg-ofyXPQUemxGFJKMq .commit-msg,#mermaid-svg-ofyXPQUemxGFJKMq .branch-label{fill:lightgrey;color:lightgrey;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq .pieTitleText{text-anchor:middle;font-size:25px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq .slice{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq g.stateGroup text{fill:#9370db;stroke:none;font-size:10px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq g.stateGroup text{fill:#9370db;fill:#333;stroke:none;font-size:10px}#mermaid-svg-ofyXPQUemxGFJKMq g.statediagram-cluster .cluster-label text{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq g.stateGroup .state-title{font-weight:bolder;fill:#000}#mermaid-svg-ofyXPQUemxGFJKMq g.stateGroup rect{fill:#ECECFF;stroke:#9370db}#mermaid-svg-ofyXPQUemxGFJKMq g.stateGroup line{stroke:#9370db;stroke-width:1}#mermaid-svg-ofyXPQUemxGFJKMq .transition{stroke:#9370db;stroke-width:1;fill:none}#mermaid-svg-ofyXPQUemxGFJKMq .stateGroup .composit{fill:white;border-bottom:1px}#mermaid-svg-ofyXPQUemxGFJKMq .stateGroup .alt-composit{fill:#e0e0e0;border-bottom:1px}#mermaid-svg-ofyXPQUemxGFJKMq .state-note{stroke:#aa3;fill:#fff5ad}#mermaid-svg-ofyXPQUemxGFJKMq .state-note text{fill:black;stroke:none;font-size:10px}#mermaid-svg-ofyXPQUemxGFJKMq .stateLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.7}#mermaid-svg-ofyXPQUemxGFJKMq .edgeLabel text{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .stateLabel text{fill:#000;font-size:10px;font-weight:bold;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-ofyXPQUemxGFJKMq .node circle.state-start{fill:black;stroke:black}#mermaid-svg-ofyXPQUemxGFJKMq .node circle.state-end{fill:black;stroke:white;stroke-width:1.5}#mermaid-svg-ofyXPQUemxGFJKMq #statediagram-barbEnd{fill:#9370db}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-cluster rect{fill:#ECECFF;stroke:#9370db;stroke-width:1px}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-cluster rect.outer{rx:5px;ry:5px}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-state .divider{stroke:#9370db}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-state .title-state{rx:5px;ry:5px}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-cluster.statediagram-cluster .inner{fill:white}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-cluster.statediagram-cluster-alt .inner{fill:#e0e0e0}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-cluster .inner{rx:0;ry:0}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-state rect.basic{rx:5px;ry:5px}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-state rect.divider{stroke-dasharray:10,10;fill:#efefef}#mermaid-svg-ofyXPQUemxGFJKMq .note-edge{stroke-dasharray:5}#mermaid-svg-ofyXPQUemxGFJKMq .statediagram-note rect{fill:#fff5ad;stroke:#aa3;stroke-width:1px;rx:0;ry:0}:root{--mermaid-font-family: '\"trebuchet ms\", verdana, arial';--mermaid-font-family: \"Comic Sans MS\", \"Comic Sans\", cursive}#mermaid-svg-ofyXPQUemxGFJKMq .error-icon{fill:#522}#mermaid-svg-ofyXPQUemxGFJKMq .error-text{fill:#522;stroke:#522}#mermaid-svg-ofyXPQUemxGFJKMq .edge-thickness-normal{stroke-width:2px}#mermaid-svg-ofyXPQUemxGFJKMq .edge-thickness-thick{stroke-width:3.5px}#mermaid-svg-ofyXPQUemxGFJKMq .edge-pattern-solid{stroke-dasharray:0}#mermaid-svg-ofyXPQUemxGFJKMq .edge-pattern-dashed{stroke-dasharray:3}#mermaid-svg-ofyXPQUemxGFJKMq .edge-pattern-dotted{stroke-dasharray:2}#mermaid-svg-ofyXPQUemxGFJKMq .marker{fill:#333}#mermaid-svg-ofyXPQUemxGFJKMq .marker.cross{stroke:#333} :root { --mermaid-font-family: \"trebuchet ms\", verdana, arial;} #mermaid-svg-ofyXPQUemxGFJKMq { color: rgba(0, 0, 0, 0.75); font: ; } select * from t_usr where id = 1 Database select * from t_usr where id =2 1由上到下 #mermaid-svg-OROFWpBsklGtNkaQ .label{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);fill:#333;color:#333}#mermaid-svg-OROFWpBsklGtNkaQ .label text{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .node rect,#mermaid-svg-OROFWpBsklGtNkaQ .node circle,#mermaid-svg-OROFWpBsklGtNkaQ .node ellipse,#mermaid-svg-OROFWpBsklGtNkaQ .node polygon,#mermaid-svg-OROFWpBsklGtNkaQ .node path{fill:#ECECFF;stroke:#9370db;stroke-width:1px}#mermaid-svg-OROFWpBsklGtNkaQ .node .label{text-align:center;fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .node.clickable{cursor:pointer}#mermaid-svg-OROFWpBsklGtNkaQ .arrowheadPath{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .edgePath .path{stroke:#333;stroke-width:1.5px}#mermaid-svg-OROFWpBsklGtNkaQ .flowchart-link{stroke:#333;fill:none}#mermaid-svg-OROFWpBsklGtNkaQ .edgeLabel{background-color:#e8e8e8;text-align:center}#mermaid-svg-OROFWpBsklGtNkaQ .edgeLabel rect{opacity:0.9}#mermaid-svg-OROFWpBsklGtNkaQ .edgeLabel span{color:#333}#mermaid-svg-OROFWpBsklGtNkaQ .cluster rect{fill:#ffffde;stroke:#aa3;stroke-width:1px}#mermaid-svg-OROFWpBsklGtNkaQ .cluster text{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}#mermaid-svg-OROFWpBsklGtNkaQ .actor{stroke:#ccf;fill:#ECECFF}#mermaid-svg-OROFWpBsklGtNkaQ text.actor>tspan{fill:#000;stroke:none}#mermaid-svg-OROFWpBsklGtNkaQ .actor-line{stroke:grey}#mermaid-svg-OROFWpBsklGtNkaQ .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333}#mermaid-svg-OROFWpBsklGtNkaQ .messageLine1{stroke-width:1.5;stroke-dasharray:2, 2;stroke:#333}#mermaid-svg-OROFWpBsklGtNkaQ #arrowhead path{fill:#333;stroke:#333}#mermaid-svg-OROFWpBsklGtNkaQ .sequenceNumber{fill:#fff}#mermaid-svg-OROFWpBsklGtNkaQ #sequencenumber{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ #crosshead path{fill:#333;stroke:#333}#mermaid-svg-OROFWpBsklGtNkaQ .messageText{fill:#333;stroke:#333}#mermaid-svg-OROFWpBsklGtNkaQ .labelBox{stroke:#ccf;fill:#ECECFF}#mermaid-svg-OROFWpBsklGtNkaQ .labelText,#mermaid-svg-OROFWpBsklGtNkaQ .labelText>tspan{fill:#000;stroke:none}#mermaid-svg-OROFWpBsklGtNkaQ .loopText,#mermaid-svg-OROFWpBsklGtNkaQ .loopText>tspan{fill:#000;stroke:none}#mermaid-svg-OROFWpBsklGtNkaQ .loopLine{stroke-width:2px;stroke-dasharray:2, 2;stroke:#ccf;fill:#ccf}#mermaid-svg-OROFWpBsklGtNkaQ .note{stroke:#aa3;fill:#fff5ad}#mermaid-svg-OROFWpBsklGtNkaQ .noteText,#mermaid-svg-OROFWpBsklGtNkaQ .noteText>tspan{fill:#000;stroke:none}#mermaid-svg-OROFWpBsklGtNkaQ .activation0{fill:#f4f4f4;stroke:#666}#mermaid-svg-OROFWpBsklGtNkaQ .activation1{fill:#f4f4f4;stroke:#666}#mermaid-svg-OROFWpBsklGtNkaQ .activation2{fill:#f4f4f4;stroke:#666}#mermaid-svg-OROFWpBsklGtNkaQ .mermaid-main-font{font-family:\"trebuchet ms\", verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ .section{stroke:none;opacity:0.2}#mermaid-svg-OROFWpBsklGtNkaQ .section0{fill:rgba(102,102,255,0.49)}#mermaid-svg-OROFWpBsklGtNkaQ .section2{fill:#fff400}#mermaid-svg-OROFWpBsklGtNkaQ .section1,#mermaid-svg-OROFWpBsklGtNkaQ .section3{fill:#fff;opacity:0.2}#mermaid-svg-OROFWpBsklGtNkaQ .sectionTitle0{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .sectionTitle1{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .sectionTitle2{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .sectionTitle3{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .sectionTitle{text-anchor:start;font-size:11px;text-height:14px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ .grid .tick{stroke:#d3d3d3;opacity:0.8;shape-rendering:crispEdges}#mermaid-svg-OROFWpBsklGtNkaQ .grid .tick text{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ .grid path{stroke-width:0}#mermaid-svg-OROFWpBsklGtNkaQ .today{fill:none;stroke:red;stroke-width:2px}#mermaid-svg-OROFWpBsklGtNkaQ .task{stroke-width:2}#mermaid-svg-OROFWpBsklGtNkaQ .taskText{text-anchor:middle;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ .taskText:not([font-size]){font-size:11px}#mermaid-svg-OROFWpBsklGtNkaQ .taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ .taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}#mermaid-svg-OROFWpBsklGtNkaQ .task.clickable{cursor:pointer}#mermaid-svg-OROFWpBsklGtNkaQ .taskText.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-OROFWpBsklGtNkaQ .taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-OROFWpBsklGtNkaQ .taskTextOutsideRight.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}#mermaid-svg-OROFWpBsklGtNkaQ .taskText0,#mermaid-svg-OROFWpBsklGtNkaQ .taskText1,#mermaid-svg-OROFWpBsklGtNkaQ .taskText2,#mermaid-svg-OROFWpBsklGtNkaQ .taskText3{fill:#fff}#mermaid-svg-OROFWpBsklGtNkaQ .task0,#mermaid-svg-OROFWpBsklGtNkaQ .task1,#mermaid-svg-OROFWpBsklGtNkaQ .task2,#mermaid-svg-OROFWpBsklGtNkaQ .task3{fill:#8a90dd;stroke:#534fbc}#mermaid-svg-OROFWpBsklGtNkaQ .taskTextOutside0,#mermaid-svg-OROFWpBsklGtNkaQ .taskTextOutside2{fill:#000}#mermaid-svg-OROFWpBsklGtNkaQ .taskTextOutside1,#mermaid-svg-OROFWpBsklGtNkaQ .taskTextOutside3{fill:#000}#mermaid-svg-OROFWpBsklGtNkaQ .active0,#mermaid-svg-OROFWpBsklGtNkaQ .active1,#mermaid-svg-OROFWpBsklGtNkaQ .active2,#mermaid-svg-OROFWpBsklGtNkaQ .active3{fill:#bfc7ff;stroke:#534fbc}#mermaid-svg-OROFWpBsklGtNkaQ .activeText0,#mermaid-svg-OROFWpBsklGtNkaQ .activeText1,#mermaid-svg-OROFWpBsklGtNkaQ .activeText2,#mermaid-svg-OROFWpBsklGtNkaQ .activeText3{fill:#000 !important}#mermaid-svg-OROFWpBsklGtNkaQ .done0,#mermaid-svg-OROFWpBsklGtNkaQ .done1,#mermaid-svg-OROFWpBsklGtNkaQ .done2,#mermaid-svg-OROFWpBsklGtNkaQ .done3{stroke:grey;fill:#d3d3d3;stroke-width:2}#mermaid-svg-OROFWpBsklGtNkaQ .doneText0,#mermaid-svg-OROFWpBsklGtNkaQ .doneText1,#mermaid-svg-OROFWpBsklGtNkaQ .doneText2,#mermaid-svg-OROFWpBsklGtNkaQ .doneText3{fill:#000 !important}#mermaid-svg-OROFWpBsklGtNkaQ .crit0,#mermaid-svg-OROFWpBsklGtNkaQ .crit1,#mermaid-svg-OROFWpBsklGtNkaQ .crit2,#mermaid-svg-OROFWpBsklGtNkaQ .crit3{stroke:#f88;fill:red;stroke-width:2}#mermaid-svg-OROFWpBsklGtNkaQ .activeCrit0,#mermaid-svg-OROFWpBsklGtNkaQ .activeCrit1,#mermaid-svg-OROFWpBsklGtNkaQ .activeCrit2,#mermaid-svg-OROFWpBsklGtNkaQ .activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}#mermaid-svg-OROFWpBsklGtNkaQ .doneCrit0,#mermaid-svg-OROFWpBsklGtNkaQ .doneCrit1,#mermaid-svg-OROFWpBsklGtNkaQ .doneCrit2,#mermaid-svg-OROFWpBsklGtNkaQ .doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}#mermaid-svg-OROFWpBsklGtNkaQ .milestone{transform:rotate(45deg) scale(0.8, 0.8)}#mermaid-svg-OROFWpBsklGtNkaQ .milestoneText{font-style:italic}#mermaid-svg-OROFWpBsklGtNkaQ .doneCritText0,#mermaid-svg-OROFWpBsklGtNkaQ .doneCritText1,#mermaid-svg-OROFWpBsklGtNkaQ .doneCritText2,#mermaid-svg-OROFWpBsklGtNkaQ .doneCritText3{fill:#000 !important}#mermaid-svg-OROFWpBsklGtNkaQ .activeCritText0,#mermaid-svg-OROFWpBsklGtNkaQ .activeCritText1,#mermaid-svg-OROFWpBsklGtNkaQ .activeCritText2,#mermaid-svg-OROFWpBsklGtNkaQ .activeCritText3{fill:#000 !important}#mermaid-svg-OROFWpBsklGtNkaQ .titleText{text-anchor:middle;font-size:18px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ g.classGroup text{fill:#9370db;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:10px}#mermaid-svg-OROFWpBsklGtNkaQ g.classGroup text .title{font-weight:bolder}#mermaid-svg-OROFWpBsklGtNkaQ g.clickable{cursor:pointer}#mermaid-svg-OROFWpBsklGtNkaQ g.classGroup rect{fill:#ECECFF;stroke:#9370db}#mermaid-svg-OROFWpBsklGtNkaQ g.classGroup line{stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5}#mermaid-svg-OROFWpBsklGtNkaQ .classLabel .label{fill:#9370db;font-size:10px}#mermaid-svg-OROFWpBsklGtNkaQ .relation{stroke:#9370db;stroke-width:1;fill:none}#mermaid-svg-OROFWpBsklGtNkaQ .dashed-line{stroke-dasharray:3}#mermaid-svg-OROFWpBsklGtNkaQ #compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ #compositionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ #aggregationStart{fill:#ECECFF;stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ #aggregationEnd{fill:#ECECFF;stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ #dependencyStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ #dependencyEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ #extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ #extensionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ .commit-id,#mermaid-svg-OROFWpBsklGtNkaQ .commit-msg,#mermaid-svg-OROFWpBsklGtNkaQ .branch-label{fill:lightgrey;color:lightgrey;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ .pieTitleText{text-anchor:middle;font-size:25px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ .slice{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ g.stateGroup text{fill:#9370db;stroke:none;font-size:10px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ g.stateGroup text{fill:#9370db;fill:#333;stroke:none;font-size:10px}#mermaid-svg-OROFWpBsklGtNkaQ g.statediagram-cluster .cluster-label text{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ g.stateGroup .state-title{font-weight:bolder;fill:#000}#mermaid-svg-OROFWpBsklGtNkaQ g.stateGroup rect{fill:#ECECFF;stroke:#9370db}#mermaid-svg-OROFWpBsklGtNkaQ g.stateGroup line{stroke:#9370db;stroke-width:1}#mermaid-svg-OROFWpBsklGtNkaQ .transition{stroke:#9370db;stroke-width:1;fill:none}#mermaid-svg-OROFWpBsklGtNkaQ .stateGroup .composit{fill:white;border-bottom:1px}#mermaid-svg-OROFWpBsklGtNkaQ .stateGroup .alt-composit{fill:#e0e0e0;border-bottom:1px}#mermaid-svg-OROFWpBsklGtNkaQ .state-note{stroke:#aa3;fill:#fff5ad}#mermaid-svg-OROFWpBsklGtNkaQ .state-note text{fill:black;stroke:none;font-size:10px}#mermaid-svg-OROFWpBsklGtNkaQ .stateLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.7}#mermaid-svg-OROFWpBsklGtNkaQ .edgeLabel text{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .stateLabel text{fill:#000;font-size:10px;font-weight:bold;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}#mermaid-svg-OROFWpBsklGtNkaQ .node circle.state-start{fill:black;stroke:black}#mermaid-svg-OROFWpBsklGtNkaQ .node circle.state-end{fill:black;stroke:white;stroke-width:1.5}#mermaid-svg-OROFWpBsklGtNkaQ #statediagram-barbEnd{fill:#9370db}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-cluster rect{fill:#ECECFF;stroke:#9370db;stroke-width:1px}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-cluster rect.outer{rx:5px;ry:5px}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-state .divider{stroke:#9370db}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-state .title-state{rx:5px;ry:5px}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-cluster.statediagram-cluster .inner{fill:white}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-cluster.statediagram-cluster-alt .inner{fill:#e0e0e0}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-cluster .inner{rx:0;ry:0}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-state rect.basic{rx:5px;ry:5px}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-state rect.divider{stroke-dasharray:10,10;fill:#efefef}#mermaid-svg-OROFWpBsklGtNkaQ .note-edge{stroke-dasharray:5}#mermaid-svg-OROFWpBsklGtNkaQ .statediagram-note rect{fill:#fff5ad;stroke:#aa3;stroke-width:1px;rx:0;ry:0}:root{--mermaid-font-family: '\"trebuchet ms\", verdana, arial';--mermaid-font-family: \"Comic Sans MS\", \"Comic Sans\", cursive}#mermaid-svg-OROFWpBsklGtNkaQ .error-icon{fill:#522}#mermaid-svg-OROFWpBsklGtNkaQ .error-text{fill:#522;stroke:#522}#mermaid-svg-OROFWpBsklGtNkaQ .edge-thickness-normal{stroke-width:2px}#mermaid-svg-OROFWpBsklGtNkaQ .edge-thickness-thick{stroke-width:3.5px}#mermaid-svg-OROFWpBsklGtNkaQ .edge-pattern-solid{stroke-dasharray:0}#mermaid-svg-OROFWpBsklGtNkaQ .edge-pattern-dashed{stroke-dasharray:3}#mermaid-svg-OROFWpBsklGtNkaQ .edge-pattern-dotted{stroke-dasharray:2}#mermaid-svg-OROFWpBsklGtNkaQ .marker{fill:#333}#mermaid-svg-OROFWpBsklGtNkaQ .marker.cross{stroke:#333} :root { --mermaid-font-family: \"trebuchet ms\", verdana, arial;} #mermaid-svg-OROFWpBsklGtNkaQ { color: rgba(0, 0, 0, 0.75); font: ; } id%2=1 id%2=0 select * from t_usr where id = 1 Database01 select * from t_usr where id = 2 Database02 2、两种技术模式的基本介绍2.1 分库分表的技术模式1）中间件Proxy模式（MyCat）Proxy属于中间层方案，在应用程序和MySQL之间搭建一层Proxy。中间层介于应用程序与数据库间，需要做一次转发，基于JDBC协议转发，例如Mycat2）Client客户端模式（Sharding-JDBC）Client模式属于客户端直连方案。此方案的优势在于轻便，对兼容性、性能以及DBA影响小。 例如当当网的sharding-jdbc，阿里的TDDL 2.1 Sharding-JDBCSharding-JDBC的基本使用总结 2.2 MyCatMyCat的基本使用总结 3、数据库表结构的自动生成3.1为什么要使用数据表自动生成在实际业务中譬如日志表，我们希望每月的日志表分开，每当下一个月创建一个新的日志表，这样既可以分担数据库压力，又可以进行分类便于查找。此时我们就需要用到Freemarker模板引擎技术来解决数据库表的自动生成。 3.2 Freemarker的基本使用Freemarker的基本使用 3.3 表结构自动生成步骤1）分析建表语句，提炼数据类型 2）使用工具类：GenerateSqlUtils，生成sql文件 3）在src/main/resources/ftl目录下创建模板文件如：sql.ftl 4）改造模板文件对于变化位置，相应填充变量即可结果如下： 1234567891011121314151617181920212223242526272829&lt;#list 0..sqlbean.db_count-1 as db_no&gt;DROP database if exists `chongba_schedule${db_no}`;CREATE DATABASE `chongba_schedule${db_no}` DEFAULT CHARACTER SET utf8;USE `chongba_schedule${db_no}`;​&lt;#list 0..sqlbean.taskinfo_count-1 as taskinfo_no&gt;CREATE TABLE `taskinfo_${taskinfo_no}` (`task_id` bigint(20) NOT NULL comment '任务id',`execute_time` datetime(3) NOT NULL comment '执行时间',`parameters` longblob comment '参数',`priority` int(11) NOT NULL comment '优先级',`task_type` int(11) NOT NULL comment '任务类型',PRIMARY KEY (`task_id`),KEY `index_taskinfo_time` (`task_type`,`priority`,`execute_time`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;&lt;/#list&gt;&lt;#list sqlbean.taskinfo_logs_monthList as month&gt;CREATE TABLE `taskinfo_logs_${month}` (`task_id` bigint(20) NOT NULL COMMENT '任务id',`execute_time` datetime(3) COMMENT '执行时间',`parameters` longblob COMMENT '参数',`priority` int(11) NOT NULL COMMENT '优先级',`task_type` int(11) NOT NULL COMMENT '任务类型',`version` int(11) NOT NULL COMMENT '版本号,用乐观锁',`status` int(11) DEFAULT '0' COMMENT '状态 0=初始化状态 1=EXECUTED 2=CANCELLED',PRIMARY KEY (`task_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;&lt;/#list&gt;&lt;/#list&gt; 4）对应yaml配置文件进行修改","link":"/2021/07/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"}],"tags":[{"name":"java aop","slug":"java-aop","link":"/tags/java-aop/"},{"name":"java 开发语言 后端","slug":"java-开发语言-后端","link":"/tags/java-%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80-%E5%90%8E%E7%AB%AF/"},{"name":"consul","slug":"consul","link":"/tags/consul/"},{"name":"mysql java","slug":"mysql-java","link":"/tags/mysql-java/"},{"name":"Java 学习","slug":"Java-学习","link":"/tags/Java-%E5%AD%A6%E4%B9%A0/"},{"name":"mysql freemarker","slug":"mysql-freemarker","link":"/tags/mysql-freemarker/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"poi excel","slug":"poi-excel","link":"/tags/poi-excel/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"jdk linux tomcat","slug":"jdk-linux-tomcat","link":"/tags/jdk-linux-tomcat/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"mysql mycat","slug":"mysql-mycat","link":"/tags/mysql-mycat/"},{"name":"mysql 锁 表锁 行锁","slug":"mysql-锁-表锁-行锁","link":"/tags/mysql-%E9%94%81-%E8%A1%A8%E9%94%81-%E8%A1%8C%E9%94%81/"},{"name":"mysql 数据库 sql","slug":"mysql-数据库-sql","link":"/tags/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93-sql/"},{"name":"mysql 索引","slug":"mysql-索引","link":"/tags/mysql-%E7%B4%A2%E5%BC%95/"},{"name":"mysql 数据库 java","slug":"mysql-数据库-java","link":"/tags/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93-java/"},{"name":"postgresql linux","slug":"postgresql-linux","link":"/tags/postgresql-linux/"},{"name":"postman","slug":"postman","link":"/tags/postman/"},{"name":"restTemplate java springboot postman","slug":"restTemplate-java-springboot-postman","link":"/tags/restTemplate-java-springboot-postman/"},{"name":"rocketmq","slug":"rocketmq","link":"/tags/rocketmq/"},{"name":"java mysql 分库分表","slug":"java-mysql-分库分表","link":"/tags/java-mysql-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"},{"name":"java spring springboot","slug":"java-spring-springboot","link":"/tags/java-spring-springboot/"},{"name":"java springboot RestTemplate","slug":"java-springboot-RestTemplate","link":"/tags/java-springboot-RestTemplate/"},{"name":"java 线程池","slug":"java-线程池","link":"/tags/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"dokcer","slug":"dokcer","link":"/tags/dokcer/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"docker linux centos java","slug":"docker-linux-centos-java","link":"/tags/docker-linux-centos-java/"},{"name":"面试 java","slug":"面试-java","link":"/tags/%E9%9D%A2%E8%AF%95-java/"},{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"java  socket","slug":"java-socket","link":"/tags/java-socket/"},{"name":"java springboot MutilpartFile","slug":"java-springboot-MutilpartFile","link":"/tags/java-springboot-MutilpartFile/"},{"name":"mybatis java mysql","slug":"mybatis-java-mysql","link":"/tags/mybatis-java-mysql/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"mysql sql java","slug":"mysql-sql-java","link":"/tags/mysql-sql-java/"},{"name":"mysql 数据库 postgresql","slug":"mysql-数据库-postgresql","link":"/tags/mysql-%E6%95%B0%E6%8D%AE%E5%BA%93-postgresql/"},{"name":"sonarqube","slug":"sonarqube","link":"/tags/sonarqube/"},{"name":"spring 数据库","slug":"spring-数据库","link":"/tags/spring-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ribbon consul stream springcloud","slug":"ribbon-consul-stream-springcloud","link":"/tags/ribbon-consul-stream-springcloud/"},{"name":"java 数据库 多线程","slug":"java-数据库-多线程","link":"/tags/java-%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"neo4j","slug":"neo4j","link":"/tags/neo4j/"},{"name":"tomcat","slug":"tomcat","link":"/tags/tomcat/"},{"name":"spring boot exception","slug":"spring-boot-exception","link":"/tags/spring-boot-exception/"},{"name":"单元测试 拦截器","slug":"单元测试-拦截器","link":"/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序算法 leetcode","slug":"排序算法-leetcode","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-leetcode/"},{"name":"链表 数据结构 leetcode","slug":"链表-数据结构-leetcode","link":"/tags/%E9%93%BE%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-leetcode/"},{"name":"快速排序 排序算法 java 数据结构","slug":"快速排序-排序算法-java-数据结构","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"servlet tomcat","slug":"servlet-tomcat","link":"/tags/servlet-tomcat/"},{"name":"java session","slug":"java-session","link":"/tags/java-session/"},{"name":"java http","slug":"java-http","link":"/tags/java-http/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"json java 字符串","slug":"json-java-字符串","link":"/tags/json-java-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"java 设计模式","slug":"java-设计模式","link":"/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"抽象类 java 类 final","slug":"抽象类-java-类-final","link":"/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-java-%E7%B1%BB-final/"},{"name":"数据结构 排序算法 插入排序 快速排序","slug":"数据结构-排序算法-插入排序-快速排序","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"符号表 数据结构 java","slug":"符号表-数据结构-java","link":"/tags/%E7%AC%A6%E5%8F%B7%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-java/"},{"name":"数据结构 栈 java","slug":"数据结构-栈-java","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88-java/"},{"name":"数据结构 队列 栈","slug":"数据结构-队列-栈","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97-%E6%A0%88/"},{"name":"二叉树 java 数据结构","slug":"二叉树-java-数据结构","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91-java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表 数据结构","slug":"链表-数据结构","link":"/tags/%E9%93%BE%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据结构 c语言","slug":"数据结构-c语言","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-c%E8%AF%AD%E8%A8%80/"},{"name":"多线程 java","slug":"多线程-java","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-java/"},{"name":"linux java cpu 多线程 线程池参数","slug":"linux-java-cpu-多线程-线程池参数","link":"/tags/linux-java-cpu-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0/"},{"name":"java 结果集","slug":"java-结果集","link":"/tags/java-%E7%BB%93%E6%9E%9C%E9%9B%86/"},{"name":"设计模式 java","slug":"设计模式-java","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/"},{"name":"java date 时间 日期 数据库","slug":"java-date-时间-日期-数据库","link":"/tags/java-date-%E6%97%B6%E9%97%B4-%E6%97%A5%E6%9C%9F-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"spring boot application","slug":"spring-boot-application","link":"/tags/spring-boot-application/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"java java8新特性","slug":"java-java8新特性","link":"/tags/java-java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"categories":[{"name":"中间件","slug":"中间件","link":"/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"遇到的问题","slug":"遇到的问题","link":"/categories/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"name":"编程工具使用总结","slug":"编程工具使用总结","link":"/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"博客搭建系列","slug":"博客搭建系列","link":"/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%B3%BB%E5%88%97/"},{"name":"面试总结","slug":"面试总结","link":"/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"name":"jvm","slug":"jvm","link":"/categories/jvm/"}]}